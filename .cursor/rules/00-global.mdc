---
description: "Primary global rules for the L9 Secure AI OS monorepo: architecture invariants, safety, and universal coding standards."
alwaysApply: true
---

# L9 Secure AI OS – Global Rules

## Project Overview

**L9 Secure AI OS** is a deterministic, multi-layered autonomous agent runtime with:
- **Kernel Stack**: 10 governance/identity/behavior kernels (MasterKernel, SafetyKernel, ExecutionKernel, etc.)
- **Agent Executor**: AgentExecutorService, AIOSRuntime, and AgentInstance for task-driven reasoning
- **Memory Substrate**: Neo4j-backed graph, PostgreSQL packet store, semantic embedding layer
- **Orchestration**: UnifiedController, TaskRouter, PlanExecutor for multi-agent task graphs
- **Tool Graph**: Registry-based tool dispatch with approval gates for high-risk operations
- **WebSocket Orchestrator**: Real-time bidirectional agent communication via WebSocket

Critical safety posture: **No silent partial work. Explicit failure semantics. Idempotent operations. Audit-first memory logging.**

---

## Universal Coding Standards

### Determinism & Reproducibility

- **No randomness in execution paths**: Use seeded PRNGs (if needed) with explicit seed injection via config.
- **Idempotent operations**: All agent tasks, tool calls, and memory writes must be replayable without side effects.
- **Explicit error semantics**: No unhandled exceptions. Always emit a failure packet to memory with root cause, stack trace, and recovery action.
- **No implicit state mutations**: All state changes must be logged to PacketEnvelope and memory substrate atomically.

### Logging, Tracing, and Audit

- **Every agent decision is a packet**: Use PacketEnvelope from memory.substrate_models for all reasoning, tool use, and decisions.
- **Packet structure**: Include source_id, agent_id, thread_id, kind (REASONING, TOOL_CALL, DECISION, MEMORY_WRITE), payload, metadata, confidence.
- **Memory ingestion**: All packets flow through MemorySubstrateService.ingest_packet() atomically. No fire-and-forget logging.
- **Audit trails**: Every tool execution, approval decision, and memory mutation must have a timestamp, actor, and justification in metadata.
- **Tracing**: Use structured logging with context (agent_id, task_id, thread_id) at every step. Avoid generic print() statements.

### Error Handling & Resilience

- **Fail loud, fail fast**: On error, immediately emit a packet to memory with kind=FAILURE, include full error context.
- **Recovery spec**: Every error packet must include a proposed recovery action (retry, escalate, rollback, skip).
- **Timeouts**: All external calls (HTTP, shell, MCP) must have explicit timeouts. No hanging tasks.
- **Circuit breakers**: For repeated failures (3+ consecutive), emit escalation to Igor (authority=IGOR_APPROVAL) before continuing.

### Memory & Storage Invariants

- **Single source of truth**: PostgreSQL packetstore is the canonical event log. Neo4j is derived view only.
- **No in-memory state across requests**: Agents must load context from memory substrate at start. No global Python objects.
- **Blob storage**: Large payloads (>10KB) go to S3 blob store, referenced via payload.blob_ref in packet.
- **Idempotent writes**: If same packet (same dedup_key) written twice, second write is a no-op. Use UUIDs + content hash.

### Message Passing & Async

- **Redis task queue**: Background jobs enqueued via TaskQueue.enqueue() with explicit task_id, queue_name, payload.
- **Rate limiting**: All external APIs and tool calls rate-limited via RateLimiter class with Redis backend.
- **No polling**: Use Redis pub/sub or WebSocket for real-time updates, not sleep-loops.
- **Async context**: Use async def for all I/O. No blocking calls in async functions.

---

## Non-Negotiable Safety & Governance Constraints

### Approval Gates for High-Risk Operations

**High-risk tools** (GMPRUN, GITCOMMIT, MACAGENTEXEC, etc.) require **explicit Igor approval** before execution:

- Tool definition includes requiresIgorApproval=True (or scoped flag in ToolDefinition).
- Before dispatch, executor checks AgentCapabilities and GovernanceApprovals tables.
- If approval required but missing, emit **BLOCKED** packet to memory with escalation path.
- Approval token includes approved_by, approved_at, approval_scope, expiration.

### Destructive Operation Constraints

**Destructive operations** (GITCOMMIT, MACAGENTEXEC shell, data deletion) must:
- Have a **dry-run mode**: Propose action with full outcome spec before executing.
- Include **rollback specification**: How to undo this if needed.
- Log **before and after state**: Packet payload includes pre-condition and post-condition assertions.
- Require **explicit confirmation**: If human-in-the-loop, escalate via WebSocket or Slack before actual execution.

### External Control & Escalation

- **User intent validation**: For any user-initiated task, verify intent via Slack thread UUID or HTTP session ID.
- **Escalation channels**: On uncertainty, L escalates to Igor via Slack DM or WebSocket.
- **Authority hierarchy**: Igor > L (CTO) > Research agents > Mac agent. Respect this in tool dispatch.
- **Audit immutability**: Once a decision packet is in memory, it cannot be deleted. Corrections are new packets.

---

## Conflict Resolution: Global vs Scoped Rules

**When multiple .mdc files apply, this hierarchy wins:**

1. **Global invariants always win** – safety, approval gates, memory substrate, error handling.
2. **Scoped rules refine, never override** – language/framework rules optimize patterns but never disable safety checks.
3. **Explicit flag overrides**: If a .mdc uses L9_ENABLE_* flags, always gate behind feature flags and log the decision.

---

## L9-Specific Patterns

### Agent Task Lifecycle

1. TaskEnvelope created (http lchat, Slack, WebSocket) with AgentTask payload.
2. TaskRouter.route() determines execution target and complexity.
3. AgentExecutorService.start_agent_task() instantiates agent + tools.
4. AIOSRuntime.execute_reasoning() loops: reason → tool_call → check_approval → dispatch.
5. All steps logged to memory via packet ingestion.
6. ExecutionResult returned with output, status, tool_calls, metadata.

### Kernel Stack Loading

- **At startup**: KernelLoader reads YAML kernels (00-masterkernel, 02-identity, 08-safety, etc.).
- **Per agent**: AgentRegistry.get_agent_config(agent_id) returns AgentConfig with kernel stack.
- **Prompts**: lcto.py builds system prompt by composing kernel sections in order.
- **Governance**: SafetyKernel constraints are enforced by executor before tool dispatch.

### Tool Registry & Capabilities

- **Tool definitions**: core.tools.toolgraph.LTOOLSDEFINITIONS (list of ToolDefinition).
- **Capability profiles**: AgentCapabilities enum (LCAPABILITIES) gates which tools agent can use.
- **Governance metadata**: ToolDefinition includes scope, requiresIgorApproval, isDestructive.
- **Runtime dispatch**: executor queries registry, checks capability + approval, then calls tool.

### Memory Packet Ingest

- **PacketEnvelope schema**: source_id, agent_id, thread_id, kind, payload, metadata, confidence.
- **Ingestion pipeline**: MemorySubstrateService.ingest_packet() → ingestion DAG → Neo4j + PostgreSQL.
- **Async persistence**: Ingestion runs in background task queue. Executor does not wait.
- **Deduplication**: Same packet (uuid) or same dedup_key not re-ingested. Idempotent.

---

## Feature Flags & Deprecation

- **L9_ENABLE_LEGACY_CHAT**: Gates old apiserver.py POST /chat (default=true, later false).
- **L9_ENABLE_LEGACY_SLACK_ROUTER**: Gates old webhookslack.py path without AgentTask (default=true, later false).
- **L9_USE_KERNELS**: If true, load kernels from files; if false, use fallback prompt (default=true).
- **L9_ENABLE_WS_ORCHESTRATOR**: If true, WebSocket routes use wstaskrouter; if false, no WS (default=true).

When adding flags, always:
1. Log the flag state at startup (use Python logging.info).
2. Document deprecation path and removal date.
3. Test both branches (flag on and off).

---

## Coding Conventions

### File Organization

- **core/agents/**: Agent executor, runtime, instance, registry. The kernel+task loop.
- **core/tools/**: Tool graph, registry, capabilities. Tool definitions and dispatch.
- **core/kernels/**: Kernel loading, yaml parsing. (Kernels themselves are YAML in config/)
- **memory/**: Substrate service, DAG, models, repository. Packet ingestion + retrieval.
- **orchestration/**: Routers, controllers, plan executor. Task graph orchestration.
- **runtime/**: Task queue, Redis client, rate limiter, WebSocket orchestrator. Background work.
- **api/**: FastAPI routers, request/response models. HTTP + WebSocket entry points.
- **services/**: Research agents, Mac tasks, utilities. Domain-specific services.

### Naming

- **Agent classes**: FooAgent (e.g., ResearcherAgent, MacAgent).
- **Service classes**: FooService (e.g., MemorySubstrateService, AgentExecutorService).
- **Data models**: FooRequest, FooResponse, FooResult for I/O; Foo for domain objects.
- **Enums**: FooKind, FooStatus, FooMode (e.g., TaskKind, ExecutionStatus).
- **Constants**: UPPERCASE for immutable config; CONSTANT_NAME for enums.

### Testing

- **Unit tests**: tests/core/agents/test_executor.py mirrors core/agents/executor.py.
- **Integration tests**: tests/integration/test_orchestrator_memory_integration.py for multi-module flows.
- **Smoke tests**: tests/docker/test_stack_smoke.py for critical paths post-docker-compose.
- **Mocks**: Use tests/mocks/ for fixture factories (MockSubstrateService, MagicMock overrides).

---

## Critical Files (Verify, Do Not Modify Without TODO)

- kernel_loader.py: Kernel YAML loading. Changing this breaks all agent identity.
- executor.py: Core agent execution loop. Changes must preserve packet logging.
- websocket_orchestrator.py: Real-time connection management. Do not modify without async safety review.
- docker-compose.yml: Infrastructure wiring. Do not change without testing full stack.
- memory_substrate_service.py: Packet ingestion and memory DAG. Mission-critical; treat as PROTECTED.

---

## Enforcement Checklist

- [ ] All agent tasks emit PacketEnvelope to memory. No silent operations.
- [ ] High-risk tool calls check approval gates before dispatch.
- [ ] Errors include recovery action. No bare exceptions in logs.
- [ ] Memory operations are idempotent. Same dedup_key = no re-write.
- [ ] Async code uses async/await. No sync I/O in async contexts.
- [ ] Timeouts on all external calls. No hanging tasks.
- [ ] Feature flags logged at startup with deprecation path.
- [ ] Tests for both flag=on and flag=off. No untested code paths.
- [ ] Critical files only changed via explicit TODO plan and GMP phases.

---

## Rule delegation

- **Testing details**: For full testing structure, coverage targets, and CI expectations, follow `50-qa-testing.mdc`.
- **Protected core surfaces**: For the authoritative list of protected core and infra files and how to change them, follow `90-protected-core.mdc`.
- **Deployment and orchestrator manifests**: For deployment-specific wiring, rollback, and smoke-test rules, follow `82-deployment-manifest.mdc`.
