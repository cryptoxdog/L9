---
description: "Autonomous agents and AI OS autonomy domain rules: safety envelopes, escalation, and irreversible action constraints."
globs:
  - "src/agents/**/*.ts"
  - "src/agents/**/*.py"
  - "src/autonomy/**/*"
  - "packages/agents/**/*"
alwaysApply: false
---

# Autonomous Agent & Autonomy Domain Rules

## Safety Envelopes & Capability Binding

### Capability Constraints

- **Agent capability matrix**: AgentCapabilities defines what agent can do (bound in AgentConfig).
- **No capability escalation**: Agent cannot grant itself new capabilities. Only Igor (via manual config change) can.
- **Runtime check**: executor.py queries agent_config.capabilities.get_tool(tool_name) before dispatch.

### Tool Authorization Scopes

- **Internal tools** (memory, reasoning): No approval needed. Always allowed.
- **High-risk tools** (GMPRUN, GITCOMMIT, MACAGENTEXEC): Require Igor approval.
- **External tools** (MCP, HTTP): Require approval per-call, with audit logging.
- **Destructive tools** (DELETE, REFORMAT, DEPLOY): Always require dry-run + explicit confirmation.

---

## Escalation Rules

### When to Escalate

**Agent must escalate to Igor (via Slack DM or WebSocket) when:**

1. **Uncertainty**: Agent confidence < 0.6 on high-impact decision.
2. **Approval needed**: High-risk tool requires approval and none cached.
3. **User clarification**: Ambiguous user request; needs human judgment.
4. **Out-of-bounds**: Requested action outside agent capability scope.
5. **Novel situation**: Encounter unseen context; request guidance.

### Escalation Protocol

- Create ESCALATION PacketEnvelope with reason, proposed_action, context, approval_required
- Ingest packet to memory
- Send Slack DM to Igor with interactive approval buttons
- Wait for response with timeout (default 300 seconds)
- Return ApprovalDecision

---

## Irreversible Action Constraints

### Destructive Operations

**Operations that cannot be undone:**
- Git commits pushed to remote
- Data deletions from databases
- Credential rotations
- Deployment to production
- Financial transactions

**For each, enforce:**

1. **Dry-run first**: Propose action with full outcome spec (files changed, data affected, etc.).
2. **Escalation to Igor**: Always requires explicit approval.
3. **Rollback spec**: Document how to undo (git revert, restore from backup, etc.).
4. **Pre/post assertions**: Log state before and after.
5. **Audit immutable**: Once committed, cannot be erased from audit log.

### Financial Transactions

- **Never auto-execute**: Always escalate to Igor first.
- **Amount thresholds**: Amounts > $X require explicit approval.
- **Recipient validation**: Cross-check recipient against approved list.
- **Audit trail**: Transaction in immutable log with timestamp, amount, recipient, approver.

---

## User Intent Validation

### Intent Extraction

- **Parse user request** for clear intent via LLM extract_intent.
- **Validate against scope**: Is this action within agent allowed capabilities?
- **Confirm ambiguity**: If multiple interpretations, ask user for clarification.

### Intent Confirmation

- Check if intent confidence < 0.8, send clarification request
- Check against user history for similar patterns
- For novel requests, escalate to Igor

---

## Multi-Step Agent Planning

### Plan Composition & Sequencing

- **Agent proposes multi-step plan** as TaskGraph with nodes and edges
- **Escalate high-risk nodes**: If plan includes destructive actions, require approval for entire plan.
- **Abort on failure**: If any step fails and continue_on_error=False, halt entire plan.

---

## Autonomy Profiles

### Agent Autonomy Levels

1. **L0_NO_ACTION**: Read-only. Agent can query memory and reason, but cannot invoke tools.
2. **L1_SAFE_READ**: Can invoke safe, read-only tools (memory, query, inspect). No writes.
3. **L2_WRITE_ISOLATED**: Can invoke write tools (memory, file creation) but not external APIs.
4. **L3_EXTERNAL_SAFE**: Can invoke safe external APIs (query APIs, no mutations).
5. **L4_EXTERNAL_WRITE_ESCALATE**: Can invoke write tools externally, but all require escalation.
6. **L5_FULL_AUTONOMY**: Can invoke any tool subject to approval gates; fewer escalations.

**Enforcement**: executor.py checks agent autonomy level before allowing tool execution.

---

## Feedback Loops & Learning

### Outcome Logging

- **Every executed action** logged with outcome as OUTCOME PacketEnvelope
- Include action, intended_outcome, actual_outcome, success, learned

### Autonomy Calibration

- **Success rate tracking**: If agent succeeds >95% of non-escalated tasks, consider raising autonomy.
- **Failure analysis**: If agent fails >5% of escalated tasks, lower autonomy or retraining.
- **Human feedback**: Igor can annotate outcomes with good decision, could improve, risky.

---

## Escalation Channels

### Primary: Slack DM to Igor

- Instant notification
- Interactive approval buttons
- Async; Igor does not need to be watching

### Secondary: WebSocket (Real-time)

- If Igor is actively monitoring L console
- Lower latency response
- For time-sensitive decisions

### Tertiary: Email Digest

- Daily summary of escalations
- Non-urgent items
- Useful for asynchronous review

---

## Governance Metadata in Tool Definitions

ToolDefinition includes:
- name, description, category (memory, execution, integration)
- scope (internal, external)
- risk_level (low, medium, high)
- is_destructive
- requires_igor_approval
- external_apis (list of APIs if applicable)
- internal_dependencies (other tools this depends on)
- agent_id (owner agent)

---

## Audit & Immutability

### Audit Log Packet Schema

AUDIT PacketEnvelope with:
- action, tool_name, agent_id
- approved_by, approval_timestamp, execution_timestamp
- input, output, outcome
- metadata with immutable=True, retention_years=7
