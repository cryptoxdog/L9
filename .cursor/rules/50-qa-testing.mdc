---
description: "Testing and QA rules for AI OS agents, runtimes, and integrations."
globs:
  - "**/*.test.ts"
  - "**/*.test.tsx"
  - "**/*.test.py"
  - "**/__tests__/**/*"
alwaysApply: false
---

# Testing & QA Rules for L9 OS

## Test Structure & Coverage

### Directory Organization

tests/
├── core/
│   ├── agents/ (test_executor.py, test_runtime.py, test_instance.py)
│   ├── tools/ (test_toolgraph.py, test_registry.py)
│   ├── kernels/ (test_kernel_loader.py)
├── memory/
│   ├── test_substrate_basic.py
│   ├── test_semantic_search.py
│   ├── test_ingestion_pipeline.py
├── integration/
│   ├── test_orchestrator_memory_integration.py
│   ├── test_kernel_agent_activation.py
│   ├── test_api_agent_integration.py
├── docker/
│   ├── test_stack_smoke.py
│   ├── test_migrations.py
├── mocks/
│   ├── kernel_mocks.py
│   ├── memory_mocks.py
│   └── orchestrator_mocks.py

### Unit Test Requirements

- **One test file per source module**: core/agents/executor.py → tests/core/agents/test_executor.py.
- **Test coverage ≥ 85%**: Critical paths (approval gates, memory, orchestration) at ≥ 95%.
- **Three test categories per module**:
  1. **Happy path**: Normal operation, assert expected output.
  2. **Error cases**: Exceptions, timeouts, malformed input.
  3. **Edge cases**: Boundary conditions, race conditions, idempotency.

### Integration Test Requirements

- **Agent + Memory**: Verify agent decision → packet ingestion → memory query chain.
- **Kernel + Agent**: Load kernels, instantiate agent, verify system prompt includes kernel rules.
- **Orchestrator + Router**: Task routed correctly by complexity, executed by right executor.
- **API + Executor**: HTTP request → AgentTask → ExecutorService → response.

---

## Python Testing Patterns

### Async Test Fixtures

- Use @pytest.fixture with async def for async fixtures
- Mock MemorySubstrateService with AsyncMock
- Create mock AgentConfig fixtures

### Async Test Functions

- Use @pytest.mark.asyncio decorator
- Assert result.status == ExecutionStatus.SUCCESS
- Verify mock methods were called

### Error Case Testing

- Use pytest.raises to verify exceptions are raised
- Verify error messages contain expected strings

### Mocking Async Dependencies

- Use AsyncMock(spec=ClassName) for typed mocks
- Configure return values for mock methods

---

## TypeScript/React Testing Patterns

### Component Unit Tests

- Use render, screen, userEvent from @testing-library/react
- Test that components render expected elements
- Test user interactions trigger expected behavior
- Test error states display correctly

### Hook Tests

- Use renderHook, waitFor from @testing-library/react
- Test initial loading state
- Test successful data fetching
- Test error handling

### MSW (Mock Service Worker) for API Mocking

- Use rest handlers for HTTP mocking
- Setup server with beforeAll/afterAll
- Reset handlers between tests

---

## Determinism & Idempotency Tests

### Determinism Test

- Set random seed before execution
- Run same task twice with same seed
- Assert outputs are identical

### Idempotency Test

- Write same packet twice with same dedup_key
- Verify second write is marked as duplicate
- Verify only one packet exists in database

---

## Regression Test Requirements

### Memory Regression Tests

- When bug is found and fixed, add test case covering the bug
- Keep regression_tests.py documenting known issues and their test coverage
- Include issue number in test docstring

---

## Smoke Tests (Post-Docker)

### Critical Path Testing

- Create lchat request
- Call handler
- Verify response status and task_id
- Query memory for packets
- Verify tool calls logged

### Health Endpoint Tests

- GET /health returns 200
- Response includes status: healthy
- All services report ok

---

## Performance & Load Tests

### Latency SLA Tests

- Run 100 requests
- Calculate p95 latency
- Assert p95 < 5.0 seconds

### Memory Ingestion Rate

- Create 1000 packets
- Use asyncio.gather for parallel ingestion
- Calculate throughput (packets/sec)
- Assert throughput > 100 pps

---

## Debugging & Logs

### Test Log Output

- Use caplog fixture with DEBUG level
- Assert expected messages in caplog.text

### Debugging Tips

- **pytest -vv**: Verbose output including print statements
- **pytest -s**: See stdout/stderr from tests
- **pytest --pdb**: Drop into debugger on failure
- **logging.debug()**: Shown with -vv flag

---

## CI/CD Integration

### Pre-Commit Hooks

- Run unit tests with coverage threshold
- Run mypy --strict type checking
- Run black --check for format verification
- Abort commit if any check fails

### GitHub Actions CI

- Checkout code
- Setup Python 3.11
- Install requirements-test.txt
- Run pytest with coverage
- Run mypy --strict
- Run black --check

---

## Canonical testing policy

- This file is the **single source of truth** for L9 testing and QA rules (structure, coverage, categories, CI test expectations).
- Other `.mdc` files (e.g., `00-global.mdc`, `80-gmp-execution.mdc`, `82-deployment-manifest.mdc`) should **reference** this document instead of re-defining detailed test patterns.
