# DORA ENFORCEMENT CONTRACT SYSTEM
## Header Metadata + Footer Trace Block

**Created:** 2026-01-02T02:04:00Z  
**Purpose:** Turn DORA requirements into enforceable contracts (CI, codegen, validation)

---

## ðŸ”’ LOCKED TERMINOLOGY: THREE DISTINCT BLOCKS

| Block | Location | Purpose | Updates |
|-------|----------|---------|---------|
| **Header Meta** | TOP of file | Module identity, governance (points to footer) | On generation |
| **Footer Meta** | BOTTOM of file | Extended metadata (header references this) | On generation |
| **DORA Block** | VERY END (after footer) | L9_TRACE_TEMPLATE runtime trace | Auto on EVERY run |

**DORA Block = L9_TRACE_TEMPLATE ONLY** â€” NOT header meta, NOT footer meta.

**See:** `Dora-Block.md` for DORA Block specification.

---

## PART 1: THE ENFORCEABLE CONTRACT

### Contract Definition (Meta-Level)

**Contract Name:** `L9.Codegen.DORAdHeader.v1.0`

**Enforcement Level:** CRITICAL (All generated files)

**Status:** MANDATORY (Codegen must fail if not met)

**Scope:** Every Python, YAML, Markdown, and JSON file generated by codegen system

---

### Contract Specification

```yaml
# .l9-codegen-dora-contract.yaml
# This file is the SOURCE OF TRUTH for DORA block requirements

dora_block_contract:
  version: 1.0.0
  status: mandatory
  enforcement_level: critical
  applies_to:
    - file_types:
        - "*.py"
        - "*.yaml"
        - "*.yml"
        - "*.md"
        - "*.json"
    - source: "codegen_system"
    - exclusions: []  # No exceptions - ALL files must comply

# THE REQUIRED DORA BLOCK (Exact Structure)
required_dora_block:
  # Format varies by file type (see PART 2)
  # But CONTENT must be identical across all files
  
  mandatory_fields:
    - component_id          # e.g., SYM-CORE-001
    - component_name        # Human-readable name
    - module_version        # Semantic version
    - created_at            # Timestamp ISO8601
    - created_by            # Codegen system
    - layer                 # foundation|intelligence|operations|learning|security
    - domain                # symbolic_computation|governance|memory|agents|etc
    - type                  # service|collector|tracker|engine|utility|adapter
    - status                # active|deprecated|experimental|maintenance
    - governance_level      # critical|high|medium|low
    - compliance_required   # Boolean
    - audit_trail           # Boolean
    - purpose               # One-line summary
    - dependencies          # List of imports/services

  optional_but_recommended:
    - security_classification
    - execution_mode
    - timeout_seconds
    - performance_tier
    - success_metrics

# CI/CD VALIDATION RULES
validation_rules:
  rule_1_presence:
    name: "DORA block must be present"
    action: "Parse file for DORA block marker"
    marker_start: "# DORA PROTOCOL METADATA"
    marker_end: "# END DORA BLOCK"
    failure_mode: FAIL_FILE_GENERATION
    error_message: "Generated file missing DORA block. Codegen must add it."

  rule_2_field_coverage:
    name: "All mandatory fields must be populated"
    minimum_fields_required: 13
    action: "Extract DORA block, count fields"
    failure_mode: FAIL_FILE_GENERATION
    error_message: "DORA block incomplete: missing {FIELD_NAME}"

  rule_3_values_not_empty:
    name: "No field can have empty or placeholder value"
    action: "Validate each field is non-empty and not a template"
    disallowed_patterns:
      - "{PLACEHOLDER}"
      - "TODO"
      - "FILL_IN"
      - ""
      - null
    failure_mode: FAIL_FILE_GENERATION
    error_message: "DORA field {FIELD_NAME} has placeholder/empty value: {VALUE}"

  rule_4_unique_component_id:
    name: "Every file must have unique component_id"
    action: "Check against existing files in repo"
    failure_mode: FAIL_FILE_GENERATION
    error_message: "component_id '{ID}' already exists in {EXISTING_FILE}"

  rule_5_consistency:
    name: "DORA fields must be consistent across related files"
    check: "If module_name is 'symbolic_computation', all files in that module must have same layer/domain"
    failure_mode: WARN_AND_FAIL
    error_message: "DORA inconsistency: {INCONSISTENCY_DETAIL}"

  rule_6_required_governance:
    name: "Critical/high-risk modules require governance_level >= high"
    action: "Check if module is in governed_modules list, enforce governance_level"
    governed_modules:
      - governance
      - memory
      - agents
      - kernel
    failure_mode: FAIL_FILE_GENERATION
    error_message: "Module {MODULE} is critical but governance_level is '{LEVEL}'. Must be 'critical' or 'high'."

# CODEGEN INSERTION RULES
codegen_rules:
  rule_1_auto_generation:
    name: "Codegen must inject DORA block automatically"
    when: "Any file is generated"
    action: "Inject DORA block at top of file (after shebang/encoding for Python)"
    position: "After file encoding declaration, before imports"
    template_source: ".l9-dora-template.{filetype}"

  rule_2_field_population:
    name: "Codegen must populate all DORA fields"
    source_of_truth: "meta.codegen.schema.yaml + instance schema"
    fields_from:
      component_id: "schema:metadata:component_id"
      component_name: "schema:metadata:component_name"
      module_version: "schema:metadata:version"
      created_at: "datetime.utcnow().isoformat()"
      created_by: "schema:metadata:created_by OR 'L9_Codegen_Engine'"
      layer: "schema:metadata:layer"
      domain: "schema:metadata:domain"
      type: "schema:metadata:type"
      status: "schema:metadata:status OR 'active'"
      governance_level: "schema:metadata:governance_level"
      compliance_required: "schema:metadata:compliance_required OR true"
      audit_trail: "schema:metadata:audit_trail OR true"
      purpose: "schema:metadata:purpose OR module docstring first line"
      dependencies: "schema:metadata:dependencies OR extract from imports"

  rule_3_no_templates:
    name: "Generated DORA blocks must contain NO template variables"
    action: "Before writing file, scan DORA block for {PLACEHOLDER} or TODO"
    failure_mode: FAIL_FILE_GENERATION
    error_message: "DORA block contains unreplaced template: {PLACEHOLDER}"

  rule_4_idempotent_generation:
    name: "Regenerating a file must preserve component_id"
    action: "If file exists, extract DORA:component_id, preserve it in regenerated DORA block"
    preserve_fields:
      - component_id
      - created_at
      - created_by
    failure_mode: FAIL_FILE_GENERATION
    error_message: "Regeneration would change component_id from {OLD_ID} to {NEW_ID}. Preserve original."

# AUDIT & REPORTING
audit_requirements:
  requirement_1_dora_registry:
    name: "Generate .l9-dora-registry.json"
    frequency: "After every codegen run"
    contents:
      - list of all files
      - component_id
      - governance_level
      - compliance_status
      - last_generated_at
    purpose: "CI can query which files are compliant"
    location: ".l9-dora-registry.json"

  requirement_2_audit_log:
    name: "Log every DORA validation to audit trail"
    entries:
      - timestamp
      - file_path
      - component_id
      - validation_result (PASS|FAIL)
      - reason_if_fail
    location: "logs/codegen-dora-audit.log"

  requirement_3_ci_gate:
    name: "CI must block merge if any DORA validation fails"
    gate_name: "dora-block-validation"
    stage: "before_merge"
    failure_action: "BLOCK_MERGE"
    report_location: "ci-reports/dora-validation.html"

# REMEDIATION
if_dora_block_missing_or_invalid:
  step_1: "CI detects DORA block failure"
  step_2: "CI creates issue: '[DORA-FAIL] {filename} - {reason}'"
  step_3: "CI runs automatic remediation (if enabled):"
    - "Extract metadata from schema"
    - "Inject DORA block"
    - "Commit with message: 'fix(dora): remediate {filename}'"
  step_4: "If auto-remediation fails, require manual review"

# ENFORCEMENT DASHBOARD
dashboard_metrics:
  metric_1_compliance_rate:
    description: "Percentage of files with valid DORA blocks"
    target: "100%"
    alert_if_below: "95%"

  metric_2_generation_failures:
    description: "Number of codegen failures due to DORA validation"
    target: "0"
    alert_if_above: "0"

  metric_3_remediation_success:
    description: "Percentage of failed DORA blocks successfully auto-remediated"
    target: "100%"
    alert_if_below: "95%"

  metric_4_governance_distribution:
    description: "Breakdown of files by governance_level"
    categories:
      - critical
      - high
      - medium
      - low

# GIT HOOKS (Local Enforcement)
pre_commit_hooks:
  hook_1_dora_presence:
    name: "Check DORA block presence"
    files: "*.py, *.yaml, *.md, *.json"
    command: ".git/hooks/validate-dora-block.sh"
    fail_on_error: true

  hook_2_dora_validity:
    name: "Validate DORA block syntax"
    files: "*.py, *.yaml, *.md, *.json"
    command: "python scripts/validate_dora_blocks.py"
    fail_on_error: true
```

---

## PART 2: DORA BLOCK FORMAT BY FILE TYPE

### Python Files (.py)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module: {component_name}
Purpose: {purpose}
"""

# ============================================================================
# DORA PROTOCOL METADATA
# ============================================================================
# Machine-readable metadata for governance, CI/CD, and audit trails
# DO NOT REMOVE OR MODIFY THE STRUCTURE OF THIS BLOCK

__dora_block__ = {
    # Component Identity (REQUIRED)
    "component_id": "{LAYER}-{ABBREV}-{NUM}",  # e.g., SYM-CORE-001
    "component_name": "{component_name}",
    "module_version": "1.0.0",
    
    # Authorship (REQUIRED)
    "created_at": "{YYYY-MM-DDTHH:MM:SSZ}",  # e.g., 2026-01-02T02:04:00Z
    "created_by": "L9_Codegen_Engine",
    
    # Classification (REQUIRED)
    "layer": "{foundation|intelligence|operations|learning|security}",
    "domain": "{domain}",
    "type": "{service|collector|tracker|engine|utility|adapter}",
    "status": "{active|deprecated|experimental|maintenance}",
    
    # Governance (REQUIRED)
    "governance_level": "{critical|high|medium|low}",
    "compliance_required": True,
    "audit_trail": True,
    
    # Purpose (REQUIRED)
    "purpose": "{One-sentence business value}",
    "dependencies": ["list", "of", "dependencies"],
}

# ============================================================================
# END DORA BLOCK
# ============================================================================

# Standard imports start here
```

### YAML/YML Files (.yaml, .yml)

```yaml
---
# ============================================================================
# DORA PROTOCOL METADATA
# ============================================================================
# Machine-readable metadata for governance, CI/CD, and audit trails
# DO NOT REMOVE OR MODIFY THE STRUCTURE OF THIS BLOCK

dora_block:
  # Component Identity (REQUIRED)
  component_id: "{LAYER}-{ABBREV}-{NUM}"  # e.g., SYM-CORE-001
  component_name: "{component_name}"
  module_version: "1.0.0"
  
  # Authorship (REQUIRED)
  created_at: "{YYYY-MM-DDTHH:MM:SSZ}"
  created_by: "L9_Codegen_Engine"
  
  # Classification (REQUIRED)
  layer: "{foundation|intelligence|operations|learning|security}"
  domain: "{domain}"
  type: "{service|collector|tracker|engine|utility|adapter}"
  status: "{active|deprecated|experimental|maintenance}"
  
  # Governance (REQUIRED)
  governance_level: "{critical|high|medium|low}"
  compliance_required: true
  audit_trail: true
  
  # Purpose (REQUIRED)
  purpose: "{One-sentence business value}"
  dependencies:
    - dependency1
    - dependency2

# ============================================================================
# END DORA BLOCK
# ============================================================================

# YAML content starts here
```

### Markdown Files (.md)

```markdown
---
# DORA PROTOCOL METADATA
# Machine-readable metadata for governance, CI/CD, and audit trails

dora_block:
  component_id: "{LAYER}-{ABBREV}-{NUM}"
  component_name: "{component_name}"
  module_version: "1.0.0"
  created_at: "{YYYY-MM-DDTHH:MM:SSZ}"
  created_by: "L9_Codegen_Engine"
  layer: "{foundation|intelligence|operations|learning|security}"
  domain: "{domain}"
  type: "{service|collector|tracker|engine|utility|adapter}"
  status: "{active|deprecated|experimental|maintenance}"
  governance_level: "{critical|high|medium|low}"
  compliance_required: true
  audit_trail: true
  purpose: "{One-sentence business value}"
  dependencies:
    - dependency1
    - dependency2

---

# Document Title

[Markdown content starts here]
```

### JSON Files (.json)

```json
{
  "_dora_block": {
    "component_id": "{LAYER}-{ABBREV}-{NUM}",
    "component_name": "{component_name}",
    "module_version": "1.0.0",
    "created_at": "{YYYY-MM-DDTHH:MM:SSZ}",
    "created_by": "L9_Codegen_Engine",
    "layer": "{foundation|intelligence|operations|learning|security}",
    "domain": "{domain}",
    "type": "{service|collector|tracker|engine|utility|adapter}",
    "status": "{active|deprecated|experimental|maintenance}",
    "governance_level": "{critical|high|medium|low}",
    "compliance_required": true,
    "audit_trail": true,
    "purpose": "{One-sentence business value}",
    "dependencies": ["dependency1", "dependency2"]
  },
  "actual_content": {}
}
```

---

## PART 3: CODEGEN SYSTEM MODIFICATIONS

### What Codegen Must Do

**Before generating ANY file:**

```python
# In codegen_engine.py or equivalent

def validate_before_generation(schema: Dict, file_type: str) -> bool:
    """
    Validate that all DORA fields are present in schema before generation.
    
    If any field is missing, raise error and STOP generation.
    """
    required_dora_fields = [
        "component_id",
        "component_name",
        "module_version",
        "created_at",
        "created_by",
        "layer",
        "domain",
        "type",
        "status",
        "governance_level",
        "compliance_required",
        "audit_trail",
        "purpose",
        "dependencies",
    ]
    
    for field in required_dora_fields:
        if field not in schema or not schema[field]:
            raise CodegenDORAfailedError(
                f"DORA field '{field}' missing in schema. Cannot generate file."
            )
    
    return True

async def generate_file_with_dora(
    schema: Dict,
    file_path: str,
    file_type: str,
    content: str,
) -> str:
    """
    Generate file with DORA block injected.
    
    1. Validate DORA fields
    2. Build DORA block from schema
    3. Inject into file at correct position
    4. Write file
    5. Validate DORA block in written file
    """
    
    # Step 1: Validate
    validate_before_generation(schema, file_type)
    
    # Step 2: Build DORA block (format depends on file_type)
    dora_block = build_dora_block_for_filetype(schema, file_type)
    
    # Step 3: Inject into content
    content_with_dora = inject_dora_block(dora_block, content, file_type)
    
    # Step 4: Write file
    with open(file_path, 'w') as f:
        f.write(content_with_dora)
    
    # Step 5: Validate written file
    if not validate_dora_block_in_file(file_path):
        raise CodegenDORAvalidationError(
            f"Generated file {file_path} failed DORA validation. Rollback."
        )
    
    # Log to audit trail
    log_dora_generation(file_path, schema["component_id"])
    
    return file_path

def build_dora_block_for_filetype(schema: Dict, file_type: str) -> str:
    """Build DORA block in correct format for file type."""
    
    if file_type == "python":
        return format_dora_python(schema)
    elif file_type in ["yaml", "yml"]:
        return format_dora_yaml(schema)
    elif file_type == "markdown":
        return format_dora_markdown(schema)
    elif file_type == "json":
        return format_dora_json(schema)
    else:
        raise CodegenUnsupportedFileTypeError(f"Unknown file type: {file_type}")

def format_dora_python(schema: Dict) -> str:
    """Format DORA block for Python files."""
    return f'''# ============================================================================
# DORA PROTOCOL METADATA
# ============================================================================

__dora_block__ = {{
    "component_id": "{schema['component_id']}",
    "component_name": "{schema['component_name']}",
    "module_version": "{schema['module_version']}",
    "created_at": "{schema['created_at']}",
    "created_by": "{schema['created_by']}",
    "layer": "{schema['layer']}",
    "domain": "{schema['domain']}",
    "type": "{schema['type']}",
    "status": "{schema['status']}",
    "governance_level": "{schema['governance_level']}",
    "compliance_required": {str(schema['compliance_required']).lower()},
    "audit_trail": {str(schema['audit_trail']).lower()},
    "purpose": "{schema['purpose']}",
    "dependencies": {schema['dependencies']},
}}

# ============================================================================
# END DORA BLOCK
# ============================================================================
'''

# Similar functions for YAML, Markdown, JSON...
```

---

## PART 4: CI/CD VALIDATION PIPELINE

### GitHub Actions / GitLab CI

```yaml
# .github/workflows/dora-validation.yml

name: DORA Block Validation

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  validate-dora-blocks:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install validation script
        run: |
          pip install pyyaml pydantic
      
      - name: Validate DORA blocks in all generated files
        run: |
          python scripts/validate_all_dora_blocks.py
          # This script:
          # 1. Finds all *.py, *.yaml, *.md, *.json files
          # 2. Checks for DORA block presence
          # 3. Validates all mandatory fields
          # 4. Checks for template placeholders
          # 5. Verifies component_id uniqueness
          # 6. Generates report
      
      - name: Check DORA registry
        run: |
          python scripts/check_dora_registry.py
          # Validates .l9-dora-registry.json is up-to-date
      
      - name: Publish DORA compliance report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: dora-compliance-report
          path: ci-reports/dora-validation.html
      
      - name: Fail if DORA validation failed
        if: failure()
        run: |
          echo "DORA validation failed. See report above."
          exit 1
```

---

## PART 5: LOCAL PRE-COMMIT HOOK

### `.git/hooks/pre-commit`

```bash
#!/bin/bash
# Validate DORA blocks before committing

echo "ðŸ” Validating DORA blocks..."

# Get list of staged files
FILES=$(git diff --cached --name-only)

FAILED=0

for file in $FILES; do
    # Skip if file doesn't exist (deleted file)
    if [ ! -f "$file" ]; then
        continue
    fi
    
    # Check if file should have DORA block
    if [[ $file == *.py || $file == *.yaml || $file == *.yml || $file == *.md || $file == *.json ]]; then
        # Check for DORA block presence
        if ! grep -q "DORA PROTOCOL METADATA" "$file"; then
            echo "âŒ $file: Missing DORA block"
            FAILED=1
        else
            echo "âœ“ $file: DORA block present"
        fi
    fi
done

if [ $FAILED -eq 1 ]; then
    echo ""
    echo "âŒ DORA validation failed. Please add DORA blocks to all files."
    echo ""
    echo "Run: python scripts/auto_add_dora_blocks.py"
    exit 1
fi

echo "âœ… All DORA blocks validated"
exit 0
```

---

## PART 6: AUTO-REMEDIATION SCRIPT

### `scripts/auto_add_dora_blocks.py`

```python
#!/usr/bin/env python3
"""
Auto-remediate missing or invalid DORA blocks.

Usage:
    python auto_add_dora_blocks.py --fix
"""

import os
import sys
import argparse
from pathlib import Path
from datetime import datetime
import yaml
import json

def fix_dora_blocks(directory: str = "."):
    """Scan directory and fix all DORA blocks."""
    
    fixed_count = 0
    failed_count = 0
    
    for file_path in Path(directory).rglob("*"):
        if file_path.is_file() and file_path.suffix in [".py", ".yaml", ".yml", ".md", ".json"]:
            try:
                if needs_dora_block(file_path):
                    inject_dora_block(file_path)
                    fixed_count += 1
                    print(f"âœ“ Fixed: {file_path}")
            except Exception as e:
                failed_count += 1
                print(f"âœ— Failed to fix {file_path}: {e}")
    
    print(f"\nResults: {fixed_count} fixed, {failed_count} failed")

def needs_dora_block(file_path: Path) -> bool:
    """Check if file needs DORA block."""
    with open(file_path, 'r') as f:
        content = f.read()
    return "DORA PROTOCOL METADATA" not in content

def inject_dora_block(file_path: Path):
    """Inject or repair DORA block in file."""
    # Implementation here
    pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--fix", action="store_true", help="Fix DORA blocks")
    args = parser.parse_args()
    
    if args.fix:
        fix_dora_blocks()
    else:
        print("Use --fix to auto-remediate DORA blocks")
```

---

## PART 7: ENFORCEMENT SUMMARY

### What Makes This Enforceable

| Component | Enforcement | When | Action |
|-----------|------------|------|--------|
| **Codegen System** | Mandatory | Before file generation | FAIL if DORA fields missing |
| **File Writer** | Mandatory | When writing file | Inject DORA block automatically |
| **File Validation** | Mandatory | After generation | FAIL if DORA validation fails |
| **Pre-Commit Hook** | Local | Before git commit | BLOCK commit if DORA missing |
| **CI/CD Pipeline** | Mandatory | On push/PR | BLOCK merge if DORA fails |
| **Audit Trail** | Continuous | Every codegen run | Log all DORA validations |
| **Registry** | Continuous | After every generation | Update .l9-dora-registry.json |
| **Dashboard** | Continuous | Real-time monitoring | Alert if compliance drops |

---

## IMPLEMENTATION CHECKLIST

- [ ] Create `.l9-codegen-dora-contract.yaml` (source of truth)
- [ ] Create `.l9-dora-template.py`, `.l9-dora-template.yaml`, etc. (format templates)
- [ ] Modify codegen engine to call `validate_before_generation()` and `generate_file_with_dora()`
- [ ] Create `scripts/validate_all_dora_blocks.py` (CI validation)
- [ ] Create `scripts/auto_add_dora_blocks.py` (remediation)
- [ ] Add `.github/workflows/dora-validation.yml` (CI/CD gate)
- [ ] Add `.git/hooks/pre-commit` (local enforcement)
- [ ] Create `.l9-dora-registry.json` (tracking)
- [ ] Add to `CONTRIBUTING.md`: "All generated files must have DORA blocks"
- [ ] Add to README: "DORA compliance is mandatory"

---

## STATUS

âœ… **ENFORCEABLE CONTRACT DEFINED**

This system makes DORA blocks:
1. **Automatic** (codegen injects them)
2. **Mandatory** (codegen fails without them)
3. **Validated** (CI/CD blocks merge if invalid)
4. **Tracked** (registry + audit logs)
5. **Auditable** (every generation logged)
6. **Remediable** (auto-fix script available)

**Result:** No file can be generated without a valid DORA block. Period.
