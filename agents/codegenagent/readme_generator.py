"""
README Generator for CodeGenAgent
=================================

Automatically generates standardized, structured README documentation
for all code produced by the CodeGenAgent system.

Follows the L9 README Suite gold-standard patterns:
- READMEs as binding contracts
- 3-layer architecture (root, subsystem, metadata)
- Explicit AI usage rules
- Scope/invariants/APIs/configuration sections

Version: 1.0.0
"""

import os
import re
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field

import structlog

logger = structlog.get_logger(__name__)


@dataclass
class ReadmeSection:
    """A single section of a README document."""
    title: str
    content: str
    required: bool = True
    order: int = 0


@dataclass
class ReadmeMetadata:
    """Structured metadata for README.meta.yaml generation."""
    location: str
    type: str  # 'module_readme', 'subsystem_readme', 'root_readme'
    subsystem: str
    owner: str = "L9 CodeGenAgent"
    version: str = "1.0.0"
    last_updated: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    invariants: List[str] = field(default_factory=list)
    ai_allowed_scopes: List[str] = field(default_factory=list)
    ai_restricted_scopes: List[str] = field(default_factory=list)
    ai_forbidden_scopes: List[str] = field(default_factory=list)


@dataclass
class GeneratedReadme:
    """Output of README generation."""
    filename: str
    content: str
    metadata: Optional[ReadmeMetadata] = None
    metadata_yaml: Optional[str] = None


class ReadmeTemplate:
    """
    Templates for different README types.
    
    Based on L9 README Suite gold-standard patterns.
    """
    
    MODULE_TEMPLATE = """# {module_name}

## Overview

{overview}

---

## Purpose

{purpose}

**Key Responsibilities:**
{responsibilities}

**Non-Goals:**
{non_goals}

---

## Installation

```bash
{install_commands}
```

---

## Quick Start

```python
{quickstart_code}
```

---

## API Reference

{api_reference}

---

## Configuration

{configuration}

---

## Data Models

{data_models}

---

## Testing

```bash
{test_commands}
```

**Test Coverage Target:** {coverage_target}%

---

## Dependencies

{dependencies}

---

## AI Usage Rules

### âœ… Allowed Scope (AI Can Modify)

{allowed_scopes}

### âš ï¸ Restricted Scope (Requires Human Review)

{restricted_scopes}

### âŒ Forbidden Scope (AI Must NOT Touch)

{forbidden_scopes}

---

## Maintenance

- **Owner:** {owner}
- **Version:** {version}
- **Last Updated:** {last_updated}
- **Generated By:** L9 CodeGenAgent

---

## License

{license_info}
"""

    SUBSYSTEM_TEMPLATE = """# {subsystem_name}

## Subsystem Overview

{overview}

---

## Responsibilities and Boundaries

### What This Subsystem Owns

{owns}

### What This Subsystem Does NOT Own

{does_not_own}

### Dependencies

{dependencies}

---

## Directory Layout

```
{directory_layout}
```

---

## Key Components

{components}

---

## Data Models and Contracts

{data_models}

---

## Execution and Lifecycle

{lifecycle}

---

## Configuration

{configuration}

---

## API Surface (Public)

{api_surface}

---

## Observability

### Logging

{logging}

### Metrics

{metrics}

---

## Testing

{testing}

---

## AI Usage Rules for This Subsystem

### âœ… Allowed Scope

{allowed_scopes}

### âš ï¸ Restricted Scope

{restricted_scopes}

### âŒ Forbidden Scope

{forbidden_scopes}

### ðŸ“š Required Pre-Reading

{pre_reading}

---

## Maintenance

- **Owner:** {owner}
- **Version:** {version}
- **Last Updated:** {last_updated}
- **Generated By:** L9 CodeGenAgent
"""

    METADATA_TEMPLATE = """# README Metadata (machine-readable)
# Generated by L9 CodeGenAgent

location: "{location}"
type: "{type}"

metadata:
  subsystem: "{subsystem}"
  owner: "{owner}"
  version: "{version}"
  last_updated: "{last_updated}"
  generated_by: "L9 CodeGenAgent"

sections:
  overview: {{ required: true }}
  responsibilities: {{ required: true }}
  api_reference: {{ required: true }}
  configuration: {{ required: true }}
  ai_rules: {{ required: true }}

invariants:
{invariants}

ai_collaboration:
  allowed_scopes:
{allowed_scopes}
  restricted_scopes:
{restricted_scopes}
  forbidden_scopes:
{forbidden_scopes}
"""


class ReadmeGenerator:
    """
    Generates standardized README documentation for CodeGenAgent outputs.
    
    Follows the L9 README Suite gold-standard:
    - READMEs as binding contracts
    - Explicit scope boundaries
    - AI usage rules
    - Machine-readable metadata
    
    Example:
        generator = ReadmeGenerator()
        readme = generator.generate_module_readme(
            module_name="SymbolicComputation",
            overview="High-performance symbolic computation engine...",
            api_functions=[
                {"name": "compute", "signature": "async def compute(...)", "description": "..."}
            ],
        )
        print(readme.content)
    """
    
    def __init__(
        self,
        templates_dir: Optional[str] = None,
        default_owner: str = "L9 CodeGenAgent",
        default_license: str = "MIT License",
    ):
        self.templates_dir = templates_dir or str(
            Path(__file__).parent.parent.parent / "codegen" / "templates" / "readme"
        )
        self.default_owner = default_owner
        self.default_license = default_license
        self._templates: Dict[str, str] = {}
        self._load_templates()
    
    def _load_templates(self) -> None:
        """Load custom templates from templates directory if available."""
        templates_path = Path(self.templates_dir)
        if templates_path.exists():
            for template_file in templates_path.glob("*.md"):
                template_name = template_file.stem
                self._templates[template_name] = template_file.read_text()
            logger.info(
                "readme_templates_loaded",
                count=len(self._templates),
                path=self.templates_dir,
            )
    
    def generate_module_readme(
        self,
        module_name: str,
        overview: str,
        purpose: str = "",
        responsibilities: Optional[List[str]] = None,
        non_goals: Optional[List[str]] = None,
        install_commands: str = "pip install -r requirements.txt",
        quickstart_code: str = "",
        api_functions: Optional[List[Dict[str, str]]] = None,
        configuration: Optional[Dict[str, Any]] = None,
        data_models: Optional[List[Dict[str, str]]] = None,
        test_commands: str = "pytest tests/",
        coverage_target: int = 80,
        dependencies: Optional[List[str]] = None,
        allowed_scopes: Optional[List[str]] = None,
        restricted_scopes: Optional[List[str]] = None,
        forbidden_scopes: Optional[List[str]] = None,
        owner: Optional[str] = None,
        version: str = "1.0.0",
    ) -> GeneratedReadme:
        """
        Generate a complete module-level README.
        
        Args:
            module_name: Name of the module (e.g., "SymbolicComputation")
            overview: 1-2 paragraph overview of what the module does
            purpose: Purpose statement and key responsibilities
            responsibilities: List of key responsibilities
            non_goals: What this module is NOT for
            install_commands: Shell commands for installation
            quickstart_code: Python example code
            api_functions: List of public API functions with signatures
            configuration: Configuration options and environment variables
            data_models: Pydantic models or data structures
            test_commands: Commands to run tests
            coverage_target: Minimum coverage percentage
            dependencies: External package dependencies
            allowed_scopes: Files/patterns AI can modify freely
            restricted_scopes: Files/patterns requiring human review
            forbidden_scopes: Files/patterns AI must never touch
            owner: Module owner (defaults to L9 CodeGenAgent)
            version: Module version
            
        Returns:
            GeneratedReadme with content and metadata
        """
        owner = owner or self.default_owner
        responsibilities = responsibilities or []
        non_goals = non_goals or ["Not intended for direct end-user use"]
        api_functions = api_functions or []
        configuration = configuration or {}
        data_models = data_models or []
        dependencies = dependencies or []
        allowed_scopes = allowed_scopes or [f"- `{module_name.lower()}/*.py` â€” Core module logic"]
        restricted_scopes = restricted_scopes or ["- Schema changes", "- API signature changes"]
        forbidden_scopes = forbidden_scopes or ["- Kernel entry points", "- Security-sensitive code"]
        
        # Format sections
        responsibilities_text = "\n".join(f"- {r}" for r in responsibilities) if responsibilities else "- See Overview"
        non_goals_text = "\n".join(f"- {ng}" for ng in non_goals)
        
        # Format API reference
        api_reference = self._format_api_reference(api_functions)
        
        # Format configuration
        config_text = self._format_configuration(configuration)
        
        # Format data models
        models_text = self._format_data_models(data_models)
        
        # Format dependencies
        deps_text = "\n".join(f"- `{d}`" for d in dependencies) if dependencies else "- See requirements.txt"
        
        # Format AI scopes
        allowed_text = "\n".join(allowed_scopes) if allowed_scopes else "- All module files"
        restricted_text = "\n".join(restricted_scopes) if restricted_scopes else "- None"
        forbidden_text = "\n".join(forbidden_scopes) if forbidden_scopes else "- None"
        
        content = ReadmeTemplate.MODULE_TEMPLATE.format(
            module_name=module_name,
            overview=overview,
            purpose=purpose or f"Provides {module_name} functionality for L9 OS.",
            responsibilities=responsibilities_text,
            non_goals=non_goals_text,
            install_commands=install_commands,
            quickstart_code=quickstart_code or f"from {module_name.lower()} import {module_name}\n\nengine = {module_name}()\nresult = await engine.run()",
            api_reference=api_reference,
            configuration=config_text,
            data_models=models_text,
            test_commands=test_commands,
            coverage_target=coverage_target,
            dependencies=deps_text,
            allowed_scopes=allowed_text,
            restricted_scopes=restricted_text,
            forbidden_scopes=forbidden_text,
            owner=owner,
            version=version,
            last_updated=datetime.now().strftime("%Y-%m-%d"),
            license_info=self.default_license,
        )
        
        # Generate metadata
        metadata = ReadmeMetadata(
            location=f"/{module_name.lower()}/README.md",
            type="module_readme",
            subsystem=module_name.lower(),
            owner=owner,
            version=version,
            ai_allowed_scopes=allowed_scopes,
            ai_restricted_scopes=restricted_scopes,
            ai_forbidden_scopes=forbidden_scopes,
        )
        
        metadata_yaml = self._generate_metadata_yaml(metadata)
        
        logger.info(
            "readme_generated",
            module=module_name,
            type="module",
            sections=12,
        )
        
        return GeneratedReadme(
            filename="README.md",
            content=content,
            metadata=metadata,
            metadata_yaml=metadata_yaml,
        )
    
    def generate_subsystem_readme(
        self,
        subsystem_name: str,
        overview: str,
        owns: Optional[List[str]] = None,
        does_not_own: Optional[List[str]] = None,
        dependencies: Optional[List[str]] = None,
        directory_layout: str = "",
        components: Optional[List[Dict[str, str]]] = None,
        data_models: Optional[List[Dict[str, str]]] = None,
        lifecycle: str = "",
        configuration: Optional[Dict[str, Any]] = None,
        api_surface: Optional[List[Dict[str, str]]] = None,
        logging: str = "",
        metrics: Optional[List[str]] = None,
        testing: str = "",
        allowed_scopes: Optional[List[str]] = None,
        restricted_scopes: Optional[List[str]] = None,
        forbidden_scopes: Optional[List[str]] = None,
        pre_reading: Optional[List[str]] = None,
        owner: Optional[str] = None,
        version: str = "1.0.0",
    ) -> GeneratedReadme:
        """
        Generate a subsystem-level README following L9 gold-standard.
        
        This is for larger subsystems that contain multiple modules.
        """
        owner = owner or self.default_owner
        owns = owns or [f"All {subsystem_name} logic"]
        does_not_own = does_not_own or ["Other subsystems"]
        dependencies = dependencies or []
        components = components or []
        data_models = data_models or []
        api_surface = api_surface or []
        metrics = metrics or []
        allowed_scopes = allowed_scopes or []
        restricted_scopes = restricted_scopes or []
        forbidden_scopes = forbidden_scopes or []
        pre_reading = pre_reading or ["- `/README.md` (root README)"]
        configuration = configuration or {}
        
        content = ReadmeTemplate.SUBSYSTEM_TEMPLATE.format(
            subsystem_name=subsystem_name,
            overview=overview,
            owns="\n".join(f"- {o}" for o in owns),
            does_not_own="\n".join(f"- {d}" for d in does_not_own),
            dependencies="\n".join(f"- `{d}`" for d in dependencies) if dependencies else "- None",
            directory_layout=directory_layout or f"{subsystem_name.lower()}/\nâ”œâ”€â”€ __init__.py\nâ”œâ”€â”€ core.py\nâ””â”€â”€ models.py",
            components=self._format_components(components),
            data_models=self._format_data_models(data_models),
            lifecycle=lifecycle or "Standard L9 service lifecycle.",
            configuration=self._format_configuration(configuration),
            api_surface=self._format_api_reference(api_surface),
            logging="Structured JSON logging via `structlog`.",
            metrics="\n".join(f"- `{m}`" for m in metrics) if metrics else "- Standard L9 metrics",
            testing=testing or f"```bash\npytest tests/{subsystem_name.lower()}/\n```",
            allowed_scopes="\n".join(allowed_scopes) if allowed_scopes else "- Application logic",
            restricted_scopes="\n".join(restricted_scopes) if restricted_scopes else "- Schema changes",
            forbidden_scopes="\n".join(forbidden_scopes) if forbidden_scopes else "- Kernel entry points",
            pre_reading="\n".join(pre_reading),
            owner=owner,
            version=version,
            last_updated=datetime.now().strftime("%Y-%m-%d"),
        )
        
        metadata = ReadmeMetadata(
            location=f"/{subsystem_name.lower()}/README.md",
            type="subsystem_readme",
            subsystem=subsystem_name.lower(),
            owner=owner,
            version=version,
            ai_allowed_scopes=allowed_scopes,
            ai_restricted_scopes=restricted_scopes,
            ai_forbidden_scopes=forbidden_scopes,
        )
        
        logger.info(
            "readme_generated",
            subsystem=subsystem_name,
            type="subsystem",
            sections=14,
        )
        
        return GeneratedReadme(
            filename="README.md",
            content=content,
            metadata=metadata,
            metadata_yaml=self._generate_metadata_yaml(metadata),
        )
    
    def generate_from_meta(self, meta: Dict[str, Any]) -> GeneratedReadme:
        """
        Generate README from a CodeGenAgent meta specification.
        
        Extracts information from the YAML spec to populate README sections.
        """
        name = meta.get("name", "Unnamed Module")
        description = meta.get("description", "")
        version = meta.get("version", "1.0.0")
        
        # Extract functions from code sections
        api_functions = []
        for code_section in meta.get("code", []):
            if code_section.get("function_name"):
                api_functions.append({
                    "name": code_section["function_name"],
                    "signature": f"def {code_section['function_name']}(...)",
                    "description": code_section.get("description", ""),
                })
        
        # Extract dependencies
        dependencies = meta.get("dependencies", [])
        
        # Extract configuration
        configuration = meta.get("configuration", {})
        
        return self.generate_module_readme(
            module_name=name,
            overview=description,
            purpose=meta.get("purpose", ""),
            responsibilities=meta.get("responsibilities", []),
            api_functions=api_functions,
            dependencies=dependencies,
            configuration=configuration,
            version=version,
        )
    
    def _format_api_reference(self, functions: List[Dict[str, str]]) -> str:
        """Format API functions into markdown."""
        if not functions:
            return "See module docstrings for API documentation."
        
        sections = []
        for func in functions:
            name = func.get("name", "unknown")
            signature = func.get("signature", "")
            description = func.get("description", "")
            example = func.get("example", "")
            
            section = f"### `{name}`\n\n"
            if signature:
                section += f"```python\n{signature}\n```\n\n"
            if description:
                section += f"{description}\n\n"
            if example:
                section += f"**Example:**\n```python\n{example}\n```\n\n"
            
            sections.append(section)
        
        return "\n".join(sections)
    
    def _format_configuration(self, config: Dict[str, Any]) -> str:
        """Format configuration options into markdown."""
        if not config:
            return "No additional configuration required."
        
        lines = ["| Variable | Type | Default | Description |", "|----------|------|---------|-------------|"]
        
        for key, value in config.items():
            if isinstance(value, dict):
                var_type = value.get("type", "str")
                default = value.get("default", "")
                description = value.get("description", "")
            else:
                var_type = type(value).__name__
                default = str(value)
                description = ""
            
            lines.append(f"| `{key}` | {var_type} | `{default}` | {description} |")
        
        return "\n".join(lines)
    
    def _format_data_models(self, models: List[Dict[str, str]]) -> str:
        """Format data models into markdown."""
        if not models:
            return "See `models.py` for Pydantic model definitions."
        
        sections = []
        for model in models:
            name = model.get("name", "Model")
            description = model.get("description", "")
            fields = model.get("fields", [])
            
            section = f"### `{name}`\n\n{description}\n\n"
            
            if fields:
                section += "| Field | Type | Description |\n|-------|------|-------------|\n"
                for field in fields:
                    section += f"| `{field.get('name', '')}` | `{field.get('type', '')}` | {field.get('description', '')} |\n"
            
            sections.append(section)
        
        return "\n".join(sections)
    
    def _format_components(self, components: List[Dict[str, str]]) -> str:
        """Format component list into markdown."""
        if not components:
            return "See module files for component documentation."
        
        sections = []
        for comp in components:
            name = comp.get("name", "Component")
            role = comp.get("role", "")
            file = comp.get("file", "")
            
            section = f"### `{name}`\n\n**Role:** {role}\n\n**File:** `{file}`\n"
            sections.append(section)
        
        return "\n".join(sections)
    
    def _generate_metadata_yaml(self, metadata: ReadmeMetadata) -> str:
        """Generate README.meta.yaml content."""
        invariants = "\n".join(f'  - "{inv}"' for inv in metadata.invariants) if metadata.invariants else '  - "Standard L9 invariants"'
        allowed = "\n".join(f'    - "{s}"' for s in metadata.ai_allowed_scopes) if metadata.ai_allowed_scopes else '    - "Application logic"'
        restricted = "\n".join(f'    - "{s}"' for s in metadata.ai_restricted_scopes) if metadata.ai_restricted_scopes else '    - "Schema changes"'
        forbidden = "\n".join(f'    - "{s}"' for s in metadata.ai_forbidden_scopes) if metadata.ai_forbidden_scopes else '    - "Kernel entry points"'
        
        return ReadmeTemplate.METADATA_TEMPLATE.format(
            location=metadata.location,
            type=metadata.type,
            subsystem=metadata.subsystem,
            owner=metadata.owner,
            version=metadata.version,
            last_updated=metadata.last_updated,
            invariants=invariants,
            allowed_scopes=allowed,
            restricted_scopes=restricted,
            forbidden_scopes=forbidden,
        )


def generate_readme_for_module(
    module_name: str,
    overview: str,
    **kwargs,
) -> GeneratedReadme:
    """
    Convenience function to generate a README for a module.
    
    Args:
        module_name: Name of the module
        overview: Module overview text
        **kwargs: Additional arguments passed to generate_module_readme
        
    Returns:
        GeneratedReadme with content and metadata
    """
    generator = ReadmeGenerator()
    return generator.generate_module_readme(module_name=module_name, overview=overview, **kwargs)


