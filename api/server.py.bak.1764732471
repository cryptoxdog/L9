"""L9 API Server â€“ Phase 2 Secure (Dedicated DB User)"""

import logging
import json
import uuid
from datetime import datetime
from typing import Dict, Any, Optional

from fastapi import FastAPI, HTTPException, Request, Depends, Header
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import psycopg2
import os

API_TOKEN = "l9_ProdToken_8e9f9c2b6c204e0182c44e8f194d0a7d"

DB_DSN = (
    "dbname=l9db "
    "user=l9_app "
    "password=8e4fXWM6Q3M87*b3 "
    "host=127.0.0.1 "
    "port=5432"
)

logger = logging.getLogger("l9")
logging_config_path = os.environ.get("L9_LOGGING_CONFIG")

if logging_config_path and os.path.exists(logging_config_path):
    import logging.config
    logging.config.fileConfig(logging_config_path, disable_existing_loggers=False)
else:
    logging.basicConfig(level=logging.INFO)

app = FastAPI(title="L9 Phase 2 Secure AI OS", version="0.2.0")

def get_conn():
    return psycopg2.connect(DB_DSN)

def init_db():
    try:
        conn = get_conn()
        conn.autocommit = True
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS tasks (
                id UUID PRIMARY KEY,
                type TEXT NOT NULL,
                payload JSONB NOT NULL,
                priority INT NOT NULL DEFAULT 5,
                status TEXT NOT NULL,
                result JSONB,
                created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                completed_at TIMESTAMP
            );
            """
        )
        cur.close()
        conn.close()
        logger.info("L9 DB initialized.")
    except Exception as e:
        logger.error(f"DB init error: {e}", exc_info=True)

init_db()

class RouteMessage(BaseModel):
    content: str
    context: Optional[Dict[str, Any]] = None

class TaskCreate(BaseModel):
    type: str
    payload: Dict[str, Any]
    priority: int = 5

def verify_token(authorization: str = Header(None)):
    if authorization != f"Bearer {API_TOKEN}":
        raise HTTPException(status_code=401, detail="Unauthorized")

@app.get("/")
async def root():
    return {"status": "L9 Phase 2 AI OS", "version": "0.2.0"}

@app.get("/os/health")
async def health():
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM tasks;")
        (task_count,) = cur.fetchone()
        cur.close()
        conn.close()
    except Exception as e:
        logger.error(f"Health check DB error: {e}", exc_info=True)
        task_count = -1
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {
            "api": "ok",
            "task_queue": task_count
        }
    }

@app.post("/os/route")
async def route_message(message: RouteMessage, auth=Depends(verify_token)):
    return {
        "status": "success",
        "message": "Phase-2 router stub",
        "received": message.content,
        "context": message.context or {}
    }

@app.post("/agent/tasks")
async def create_task(task: TaskCreate, auth=Depends(verify_token)):
    task_id = str(uuid.uuid4())
    conn = get_conn()
    conn.autocommit = True
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO tasks (id, type, payload, priority, status)
        VALUES (%s, %s, %s, %s, 'pending');
        """,
        (task_id, task.type, json.dumps(task.payload), task.priority),
    )
    cur.close()
    conn.close()
    logger.info(f"Task created: {task_id} ({task.type})")
    return {"task_id": task_id, "status": "queued"}

@app.api_route("/agent/tasks/next", methods=["GET", "POST"])
async def get_next_task(request: Request, auth=Depends(verify_token)):
    conn = get_conn()
    conn.autocommit = True
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, type, payload, priority, status, created_at
        FROM tasks
        WHERE status = 'pending'
        ORDER BY priority ASC, created_at ASC
        LIMIT 1;
        """
    )
    row = cur.fetchone()
    if not row:
        cur.close()
        conn.close()
        return {"status": "no_tasks"}
    task_id, ttype, payload_json, priority, status, created_at = row
    cur.execute("UPDATE tasks SET status = 'assigned' WHERE id = %s;", (task_id,))
    cur.close()
    conn.close()
    try:
        payload = payload_json if isinstance(payload_json, dict) else json.loads(payload_json)
    except Exception:
        payload = {}
    logger.info(f"Assigned task: {task_id}")
    return {
        "id": str(task_id),
        "type": ttype,
        "payload": payload,
        "priority": priority,
        "status": "assigned",
        "created_at": created_at.isoformat() if created_at else None,
    }

@app.post("/agent/tasks/{task_id}/result")
async def submit_result(task_id: str, result: Dict[str, Any], auth=Depends(verify_token)):
    conn = get_conn()
    conn.autocommit = True
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE tasks
        SET result = %s,
            status = 'completed',
            completed_at = NOW()
        WHERE id = %s;
        """,
        (json.dumps(result), task_id),
    )
    updated = cur.rowcount
    cur.close()
    conn.close()
    if updated == 0:
        raise HTTPException(status_code=404, detail="Task not found")
    logger.info(f"Task completed: {task_id}")
    return {"status": "accepted"}

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled error: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"},
    )
