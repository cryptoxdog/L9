# SymPy Extraction Glue Layer v6.0
# Maps symbolic_computation_service_v6.md schema to code generation patterns

schema_to_code:
  
  # Configuration module mapping
  config:
    template: pydantic_config.py.j2
    target: config.py
    fields:
      - cache_enabled: bool = True
      - cache_size: int = 128
      - default_backend: str = "numpy"
      - enable_metrics: bool = True
      - codegen_temp_dir: str = "/tmp/sympy_codegen"
      - default_language: str = "C"
      - max_expression_length: int = 10000
      - allow_dangerous_functions: bool = False
  
  # Core evaluator module
  core_evaluator:
    template: expression_evaluator.py.j2
    target: core/expression_evaluator.py
    requires: [sympy, numpy, functools, L9.core.memory_manager]
    lines: 250-350
    functions:
      - evaluate_expression:
          signature: "async def evaluate_expression(expr: str, variables: dict, backend: str = 'numpy') -> ComputationResult"
          docstring: "Evaluate symbolic expression numerically with caching"
          logic: "Use lambdify for numpy backend, math for scalar, mpmath for precision"
      - compile_with_lambdify:
          signature: "def compile_with_lambdify(expr, variables: List[str]) -> callable"
          docstring: "Compile expression to NumPy function"
          logic: "sympy.lambdify(variables, expr, modules='numpy')"
      - compile_with_autowrap:
          signature: "def compile_with_autowrap(expr, variables: List[str], language: str) -> callable"
          docstring: "Compile expression to C/Fortran function"
          logic: "sympy.utilities.autowrap.autowrap(expr, args=variables, language=language)"
    cache_integration:
      - type: "lru_cache"
        decorator: "@functools.lru_cache(maxsize=config.cache_size)"
        target: "evaluate_expression"
      - type: "redis"
        method: "redis_client.get/set(f'sympy:{expr_hash}:{backend}')"
        target: "evaluate_expression result caching"
  
  # Code generator module
  core_generator:
    template: code_generator.py.j2
    target: core/code_generator.py
    requires: [sympy.utilities.codegen, sympy.Function]
    lines: 150-200
    functions:
      - generate_code:
          signature: "async def generate_code(expr: str, variables: List[str], language: str, function_name: str) -> CodeGenResult"
          docstring: "Generate compilable code from expression"
          logic: "Use sympy.utilities.codegen.codegen() for C/Fortran/Python"
      - compile_generated:
          signature: "def compile_generated(source_code: str, language: str) -> callable"
          docstring: "Compile generated code to executable"
          logic: "Use subprocess to compile C/Fortran, importlib for Python"
  
  # Optimizer module
  core_optimizer:
    template: optimizer.py.j2
    target: core/optimizer.py
    requires: [sympy.simplify, sympy.cse_main]
    lines: 100-150
    functions:
      - optimize_expression:
          signature: "def optimize_expression(expr) -> optimized_expr"
          docstring: "Simplify expression for faster computation"
          logic: "sympy.simplify(expr) + sympy.cse(expr) for CSE"
  
  # Cache manager module
  core_cache:
    template: cache_manager.py.j2
    target: core/cache_manager.py
    requires: [functools, redis, L9.core.memory_manager]
    lines: 150-200
    functions:
      - cache_expression:
          signature: "def cache_expression(expr: str, backend: str, result: Any) -> bool"
          docstring: "Cache evaluation result in Redis"
      - get_cached_result:
          signature: "def get_cached_result(expr: str, backend: str) -> Optional[Any]"
          docstring: "Retrieve cached result"
  
  # Metrics module
  core_metrics:
    template: metrics.py.j2
    target: core/metrics.py
    requires: [time, logging, L9.core.memory_manager]
    lines: 100-150
    functions:
      - record_evaluation:
          signature: "def record_evaluation(expr: str, backend: str, duration_ms: float, success: bool)"
      - get_metrics_summary:
          signature: "def get_metrics_summary(last_hours: int = 24) -> dict"
  
  # Validator module
  core_validator:
    template: validator.py.j2
    target: core/validator.py
    requires: [pydantic, re, sympy]
    lines: 100-150
    validation_rules:
      - rule: "max_expression_length must be enforced"
      - rule: "Dangerous functions must be blocked if allow_dangerous_functions=false"
  
  # Models module (Pydantic)
  core_models:
    template: models.py.j2
    target: core/models.py
    requires: [pydantic, enum]
    lines: 80-120
    models:
      - ComputationRequest
      - CodeGenRequest
      - ComputationResult
      - CodeGenResult
      - HealthStatus
  
  # API routes module
  api_routes:
    template: api_routes.py.j2
    target: api/routes.py
    requires: [fastapi, L9.core.memory_manager, L9.core.governance]
    endpoints:
      - POST /symbolic/evaluate
      - POST /symbolic/generate_code
      - POST /symbolic/optimize
      - GET /symbolic/metrics
      - GET /symbolic/health
  
  # Tool registry module
  symbolic_tool:
    template: tool_registry_entry.py.j2
    target: tools/symbolic_tool.py
    requires: [L9.tools.registry, L9.core.symbolic_computation]
    class_name: SymPyTool

# Enforcement rules
enforcement:
  security:
    - rule: "No raw eval() or exec() calls"
    - rule: "All expressions validated before processing"
  
  memory:
    - rule: "All Redis operations go through memory_manager"
    - rule: "All Postgres operations use connection pool"
  
  governance:
    - rule: "All critical operations checked against governance policy"
    - rule: "Igor/Compliance anchors must be reachable"
  
  testing:
    - rule: "Coverage >= 85%, pass rate >= 95%"

# Quality gates
quality_gates:
  - gate: "No TODOs in generated code"
  - gate: "All imports resolvable"
  - gate: "All tests passing >= 95%"
  - gate: "Code coverage >= 85%"
  - gate: "All governance anchors reachable"
  - gate: "No circular imports"
