# ============================================================================
# L9 CODEGEN SYSTEM - META SCHEMA TEMPLATE v6.0
# ============================================================================
# Purpose:
#   Master template for ingesting multi-agent schema collections and
#   orchestrating production-grade code extraction with maximum leverage & scale.
#
# Usage:
#   This file is the SOURCE OF TRUTH for codegen. Store in:
#   /codegen/templates/meta.codegen.schema.yaml
#
#   Companion files stored in /codegen/templates/meta/:
#   - meta.extraction.sequence.yaml
#   - meta.validation.checklist.yaml
#   - meta.dependency.graph.yaml
#   - meta.shared.configuration.yaml
#
# Integration:
#   1. User provides schema collection (e.g., TensorAIOS_AIOS_Layer_Schemas_v6.md)
#   2. Load this template + companion files
#   3. Instantiate schema.input_schemas from collection
#   4. Pass to Universal-Schema-Extractor-v6.0 with Glue
#   5. Extractor reads this template, enforces patterns, validates output
#   6. All generated files inherit governance, memory, communication, testing from this template
#
# ============================================================================

---

system: L9 Codegen Meta Schema
title: L9 Codegen System - Universal Multi-Agent Schema Processor v6.0
version: 6.0.0
created: 2025-12-12
updated: 2025-12-12
owner: L9 System Architect

purpose: |-
  Provide a unified, reusable template for ingesting arbitrary multi-agent
  schema collections and orchestrating production-grade code + docs + tests
  extraction with deterministic ordering, dependency management, governance
  integration, and validation at every phase.

domain: L9 Codegen
type: codegen-meta-schema
production_ready: true

---

## SECTION 1: SCHEMA INPUT INTERFACE

schema:
  input:
    collection_type: string  # e.g., "tensoraios_ecosystem", "agent_stack", "domain_bridge"
    collection_version: string  # e.g., "v6.0.0"
    collection_description: string  # Narrative description
    total_agents: integer  # Number of agents in collection
    shared_substrate: list  # Shared memory, governance, communication

    schemas: list  # Array of schema objects
      - schema_id: string  # Unique ID (e.g., "tensoraios", "mainagent")
        schema_file: string  # Filename (e.g., "L9_TensorAIOS_Schema_v6.yaml")
        agent_name: string  # Human-readable name
        agent_role: string  # Role in ecosystem
        rootpath: string  # Target folder (e.g., "L9/core/tensoraios")
        extraction_order: integer  # Sequence number (1-N)
        depends_on: list  # Schema IDs this depends on
        dependencies:
          hard: list  # Must be extracted first
          soft: list  # Should be extracted first
        expected_artifacts:
          python_modules: integer  # Expected .py file count
          documentation: integer  # Expected .md file count
          tests: integer  # Expected test file count
          manifest: boolean  # Generates manifest.json?
        validation_criteria: list  # Checklist items for this agent

  output:
    root_folder: string  # /codegen/extractions/[timestamp]/
    generated_code_folder: string  # /codegen/extractions/[timestamp]/code/
    generated_docs_folder: string  # /codegen/extractions/[timestamp]/docs/
    generated_tests_folder: string  # /codegen/extractions/[timestamp]/tests/
    generated_manifests_folder: string  # /codegen/extractions/[timestamp]/manifests/
    log_folder: string  # /codegen/extractions/[timestamp]/logs/
    evidence_report: string  # Full extraction report with all 10 sections

---

## SECTION 2: EXTRACTION ORCHESTRATION

extraction:
  mode: sequential_with_parallel_option
  
  orchestration:
    # Sequential execution ensures dependencies are satisfied
    mode: sequential
    reason: |-
      Extract in dependency order. Schema N may import from Schema N-1.
      Sequential guarantees availability. Once all agents extracted,
      run integration tests in parallel.
    
    # Parallel option for experienced teams
    parallel_after_phase: 3
    reason: |-
      After core infrastructure (phase 1-3), later agents (4-5) may extract
      in parallel if they share only read-only dependencies. Reduces total
      extraction time by ~30%.
  
  phase_definitions:
    phase_0_research_and_lock:
      name: Research & TODO Plan Lock
      description: |-
        Examine schema collection, extract ground truth about dependencies,
        create deterministic TODO plan locked in this file.
      actions:
        - verify_schema_files_provided
        - extract_agent_metadata
        - build_dependency_graph
        - determine_extraction_order
        - create_locked_todo_plan
        - estimate_artifact_count
      output: locked_extraction_sequence (below)
      duration_minutes: 15
    
    phase_1_baseline_confirmation:
      name: Baseline Confirmation
      description: |-
        Verify extraction targets exist, check line numbers, confirm
        no blocking dependencies, test imports.
      per_agent_checklist:
        - target_directory_accessible: boolean
        - all_link_targets_exist: boolean
        - no_circular_imports_detected: boolean
        - memory_backends_available: boolean
        - governance_layer_accessible: boolean
      duration_minutes_per_agent: 5
    
    phase_2_implementation:
      name: Implementation
      description: |-
        Execute exact schema-to-code transformation. Generate all Python
        modules, docs, tests per schema specification.
      per_agent_checklist:
        - all_generatefiles_created: boolean
        - all_generatedocs_created: boolean
        - all_tests_created: boolean
        - imports_path_correct: boolean
        - feature_flags_applied: boolean
        - governancebridges_wired: boolean
      duration_minutes_per_agent: 30
    
    phase_3_enforcement:
      name: Enforcement
      description: |-
        Add guards, validators, safety layers. Ensure L9 invariants.
      per_agent_checklist:
        - input_validation_added: boolean
        - output_bounds_checking: boolean
        - rate_limiting_configured: boolean
        - audit_logging_enabled: boolean
        - governance_constraint_checks: boolean
        - feature_flag_tests: boolean
      duration_minutes_per_agent: 10
    
    phase_4_validation:
      name: Validation
      description: |-
        Run happy path, error cases, regression tests. Verify each agent.
      per_agent_checklist:
        - positive_tests_passing: percentage  # >= 95%
        - negative_tests_passing: percentage  # >= 95%
        - regression_tests_passing: percentage  # >= 95%
        - no_new_regressions: boolean
        - import_chain_works: boolean
      duration_minutes_per_agent: 15
    
    phase_5_recursive_verification:
      name: Recursive Verification
      description: |-
        Compare generated files against schema. Verify scope hasn't drifted.
        Confirm L9 patterns & governance links preserved.
      checklist:
        - every_generatefile_in_schema_exists: boolean
        - every_linkexisting_correctly_imported: boolean
        - governance_anchors_wired: boolean
        - memory_topology_matches_schema: boolean
        - communication_stack_matches_schema: boolean
        - no_scope_drift_detected: boolean
      duration_minutes: 20
    
    phase_6_finalization:
      name: Finalization
      description: |-
        Create FINAL DEFINITION OF DONE. Write evidence report with all
        10 required sections. Mark every checklist item with evidence.
      deliverables:
        - final_definition_of_done: markdown
        - evidence_report_all_phases: markdown
        - extraction_manifest: json
        - deployment_readiness_assessment: markdown
      duration_minutes: 30

---

## SECTION 3: LOCKED EXTRACTION SEQUENCE

extraction_sequence:
  total_agents: variable  # Filled at runtime
  total_estimated_python_modules: variable
  total_estimated_documentation_files: variable
  total_estimated_test_files: variable
  total_estimated_duration_hours: variable
  
  # TEMPLATE FOR EACH AGENT (instantiate from input_schemas above)
  agent_template:
    agent_id: string  # Unique identifier
    agent_name: string  # Human-readable name
    rootpath: string  # Target extraction folder
    extraction_order_number: integer  # 1, 2, 3, ...
    extraction_phase: string  # "phase_2_implementation"
    
    dependencies:
      hard: list  # [agent_id, ...]  # Must extract before this agent
      soft: list  # [agent_id, ...]  # Should extract before this agent
    
    schema_source: string  # Filename from input
    
    expected_artifacts:
      python_modules: integer  # Count
      documentation_files: integer  # Count
      test_files: integer  # Count
      manifest_file: boolean
      logging_files: list  # [path, path, ...]
    
    validation_gates:
      phase_1_baseline:
        - target_directory_accessible
        - memory_backends_available
        - governance_anchors_reachable
      phase_2_implementation:
        - all_generatefiles_created
        - all_generatedocs_created
        - all_tests_created
        - feature_flags_applied
      phase_4_validation:
        - positive_tests: ">= 95%"
        - negative_tests: ">= 95%"
        - regression_tests: ">= 95%"
      phase_5_recursive_verification:
        - every_generatefile_in_schema_exists
        - governance_links_intact
        - no_scope_drift
    
    success_indicators:
      all_phases_complete: boolean
      no_assumptions_made: boolean
      no_drift_detected: boolean

---

## SECTION 4: SHARED CONFIGURATION (All Agents)

shared_configuration:
  # Prevent duplication: all agents read from this section
  
  memory_topology:
    working_memory:
      type: redis_cluster
      connection: "${L9_REDIS_URL}"
      keyspace_prefix: l9_codegen_generated
      ttl_seconds: 3600
    
    episodic_memory:
      type: postgres_pgvector
      connection: "${L9_POSTGRES_URL}"
      extensions: [pgvector]
    
    semantic_memory:
      type: neo4j_auradb
      connection: "${L9_NEO4J_URL}"
    
    causal_memory:
      type: hypergraphdb
      connection: "${L9_HYPERGRAPH_URL}"
    
    archive:
      type: s3_durable
      bucket: "${L9_ARCHIVE_BUCKET}"
      prefix: "codegen_extractions/"
      retention: "indefinite"
  
  governance:
    anchors:
      - name: Igor
        role: L9 Executive Architect
        contact: email + slack_critical
      - name: System Oversight Committee
        members: [domain_lead_1, domain_lead_2]
        contact: governance_bus_notification
      - name: Compliance Officer
        role: Regulatory / Policy
        contact: governance_bus_notification
    
    mode: hybrid
    human_override: true
    compliance_auditor: L9/governance/auto_audit_codegen_extraction.py
    
    escalation_policy: |-
      Auto-escalate if:
      - Any generated code has TODO or placeholder
      - Test coverage < 95%
      - Governance links missing
      - Feature flags not applied
      - Scope drift detected
      - Dependencies not satisfied
  
  communication:
    primary_protocol: PacketEnvelope  # L9 native
    secondary_protocol: event_stream  # cognition_bus
    tertiary_protocol: REST/gRPC  # For external integrations
    authentication: signed_tokens + role_based_access
  
  logging:
    root_folder: L9/logs/codegen_extractions/
    per_agent: "${root}/${agent_id}/"
    structured_logging: true
    audit_trail: immutable
  
  monitoring:
    dashboards_root: L9/monitoring/codegen_extractions/
    metrics:
      - extraction_phase_duration
      - code_quality_score
      - test_coverage_percent
      - governance_compliance
      - artifact_generation_count
  
  feature_flags:
    L9_ENABLE_CODEGEN_STRICT_MODE: true
      # Fail on any TODO, placeholder, or incomplete code
    L9_ENABLE_GOVERNANCE_ENFORCEMENT: true
      # All escalations checked before artifact release
    L9_ENABLE_MEMORY_SUBSTRATE_VALIDATION: true
      # Verify all memory backend connections
    L9_ENABLE_DEPENDENCY_VALIDATION: true
      # Verify imports and dependency graph
    L9_ENABLE_TEST_GENERATION: true
      # Generate unit + integration tests
    L9_ENABLE_EXTRACTION_PHASES: true
      # Execute all 6 phases (0-6)
    L9_ENABLE_EVIDENCE_REPORTING: true
      # Generate full evidence report with 10 sections

---

## SECTION 5: UNIVERSAL SCHEMA EXTRACTOR GLUE

# This section is REFERENCE ONLY. The actual Glue file lives at:
# /codegen/templates/glue/L9_Universal_Schema_Extractor_Glue_v6.yaml
#
# But we include a pointer here so extraction workflows know where to find it.

extractor_glue:
  location: /codegen/templates/glue/L9_Universal_Schema_Extractor_Glue_v6.yaml
  purpose: |-
    Maps schema YAML fields to code generation patterns.
    Defines how to convert:
      system / module / name -> folder structure
      cursorinstructions.generatefiles -> .py file stubs
      cursorinstructions.generatedocs -> .md documentation
      postgeneration -> manifest.json creation
    The Glue is the TRANSLATOR between schema and code.

extractor_prompt:
  location: /codegen/templates/prompts/Universal-Schema-Extractor-v6.0.md
  purpose: |-
    Claude/Cursor instruction prompt. Tell the model:
    "Given input schema + this template + the Glue file, extract
     production-grade code matching these patterns."

---

## SECTION 6: VALIDATION & QUALITY GATES

validation:
  # These gates are applied to every extracted agent
  
  code_quality:
    - no_todos: required
    - no_placeholders: required
    - no_incomplete_comments: required
    - function_signatures_complete: required
    - docstrings_present: required
    - imports_resolvable: required
    - feature_flags_applied: required
  
  testing:
    - unit_tests_generated: required
    - positive_test_cases: ">= 5 per module"
    - negative_test_cases: ">= 3 per module"
    - integration_tests: required
    - test_coverage: ">= 85%"
    - all_tests_passing: required
  
  governance:
    - governance_bridge_wired: required
    - audit_logging_configured: required
    - escalation_logic_present: required
    - feature_flags_honored: required
    - compliance_checker_present: required
  
  memory:
    - memory_bridges_created: required
    - all_memory_layers_accessed: required
    - episodic_logging_enabled: required
    - semantic_graph_update_logic: required
    - causal_tracing_enabled: required
  
  dependencies:
    - no_circular_imports: required
    - all_hard_dependencies_satisfied: required
    - all_soft_dependencies_satisfied: required
    - linkexisting_targets_verified: required
    - import_paths_match_schema: required
  
  documentation:
    - README.md exists and complete: required
    - API_SPEC.md exists (if agent has endpoints): required
    - ARCHITECTURE.md exists: required
    - CONFIG.md exists: required
    - Inline code documentation: required
  
  manifest:
    - manifest.json generated: required
    - manifest syntax valid: required
    - all_artifacts_listed: required
    - deployment_ready_flag: required

---

## SECTION 7: PHASE-BY-PHASE EXECUTION TEMPLATE

execution_template:
  # For each agent, execute these phases in order
  
  phase_0:
    title: Research & TODO Plan Lock
    activities:
      - Read schema YAML in detail
      - Extract all fields (system, module, name, rootpath, etc.)
      - Build dependency graph from depends_on
      - Create locked TODO list
      - Estimate artifact counts
    output: locked_todo_list (recorded in this file)
    sign_off: "Phase 0 complete. TODO plan locked. No changes without re-plan."
  
  phase_1:
    title: Baseline Confirmation
    activities:
      - Verify target directory accessible
      - Check memory backends reachable
      - Verify governance anchors online
      - Test imports work (mock if needed)
      - Confirm no blocking dependencies
    output: baseline_confirmation_report
    sign_off: "Phase 1 complete. All targets ready. Proceed to implementation."
  
  phase_2:
    title: Implementation
    activities:
      - Generate all files in generatefiles list
      - Generate all docs in generatedocs list
      - Generate test stubs for test_generation
      - Wire linkexisting imports
      - Apply feature flags
    output: all_generated_artifacts
    sign_off: "Phase 2 complete. All artifacts generated. Code review next."
  
  phase_3:
    title: Enforcement
    activities:
      - Add input validation to all functions
      - Add output bounds checking
      - Add rate limiting (if applicable)
      - Enable audit logging everywhere
      - Wire governance bridges
      - Add safety layer checks
    output: hardened_artifacts
    sign_off: "Phase 3 complete. All safety layers in place."
  
  phase_4:
    title: Validation
    activities:
      - Run positive path tests (happy case)
      - Run negative path tests (error cases)
      - Run regression tests
      - Check test coverage >= 85%
      - Verify all imports work
    output: test_report_with_coverage
    sign_off: "Phase 4 complete. Tests passing. Code ready."
  
  phase_5:
    title: Recursive Verification
    activities:
      - Compare every generated file to schema
      - Verify governance links intact
      - Verify memory topology matches schema
      - Check no circular imports
      - Detect any scope drift
    output: verification_report
    sign_off: "Phase 5 complete. No drift detected. Ready for finalization."
  
  phase_6:
    title: Finalization
    activities:
      - Create FINAL DEFINITION OF DONE
      - Write evidence report with all 10 sections
      - Generate extraction manifest
      - Create deployment readiness assessment
      - Sign off all phases complete
    output: |
      - final_definition_of_done.md
      - evidence_report.md (all 10 sections required)
      - extraction_manifest.json
      - deployment_readiness.md
    sign_off: "All phases (0-6) complete. No assumptions. No drift."

---

## SECTION 8: EVIDENCE REPORT STRUCTURE (Required)

evidence_report:
  # Extractor MUST produce this report with all 10 sections for EVERY agent
  
  sections: 10  # MANDATORY
  
  required_sections:
    1_schema_input_summary: |-
      Input schema name, version, purpose, agent count.
      List all input files provided to extractor.
    
    2_locked_todo_plan: |-
      Exact TODO list. Every TODO has:
      - File path
      - Line numbers (start-end)
      - Action verb (Replace/Insert/Delete/Wrap)
      - Target code or pseudocode
      - Expected behavior after change
    
    3_phase_0_research: |-
      Ground truth about schema. What dependencies exist?
      What memory backends needed? What governance anchors?
      Any assumptions made? None allowed.
    
    4_phase_1_baseline: |-
      Checklist: targets accessible? dependencies met?
      Evidence: file listings, import tests, connections verified.
    
    5_phase_2_implementation: |-
      Every TODO executed. File-by-file summary:
      - Filename, line count, purpose
      - Imports added / code changed
      - Feature flags applied
      Evidence: git diff or file listing
    
    6_phase_3_enforcement: |-
      Safety layers added. Input validation, output checks,
      rate limiting, audit logging, governance bridges.
      Evidence: line numbers of added code
    
    7_phase_4_validation: |-
      Test results. Positive/negative/regression test counts,
      coverage report. All tests passing?
      Evidence: test output log, coverage report
    
    8_phase_5_recursive_verification: |-
      Schema vs generated code comparison. Every artifact listed?
      Dependencies satisfied? No scope drift?
      Evidence: checklist with yes/no per item
    
    9_governance_and_compliance: |-
      Governance bridges wired? Escalation logic present?
      Anchors notified? Compliance checks in place?
      Evidence: file paths of governance code
    
    10_final_declaration: |-
      SIGNED-OFF declaration stating:
      "All phases (0â€“6) complete. No assumptions. No drift.
       Ready for production deployment."
      Signature: [Phase 6 finalization timestamp]

---

## SECTION 9: DEPLOYMENT INTEGRATION

deployment:
  # After extraction complete, how to integrate into L9 ecosystem
  
  step_1_push_to_repo:
    action: git add + git commit + git push
    folder: extracted artifacts to /codegen/extractions/[timestamp]/
    scope: code/, docs/, tests/, manifests/, logs/
  
  step_2_run_integration_tests:
    action: pytest -v L9/tests/codegen_integration/
    scope: all extracted agents together
    requirement: "95%+ pass rate"
  
  step_3_wire_cross_agent_imports:
    action: Update linkexisting references for inter-agent calls
    example: "PlastOS Adapter imports Main Agent; Trainer imports TensorAIOS"
  
  step_4_create_unified_config:
    action: Generate shared config file (e.g., tensoraios_ecosystem_config.yaml)
    contains: Memory backends, governance anchors, logging, API endpoints
  
  step_5_deploy_to_vps:
    action: Run L9/deployment/deploy_extracted_agents.sh
    verification: healthchecks, smoke tests, alerting rules
  
  step_6_notify_governance:
    action: Send escalation to governance anchors + Igor
    content: Extraction summary, test results, deployment status

---

## SECTION 10: INTEGRATION INSTRUCTIONS

integration:
  # How to use this template in practice
  
  workflow_step_1_gather_input_schemas:
    user_action: |-
      Provide schema collection (e.g., markdown file with 5 agent schemas).
      Save to /codegen/input_schemas/[collection_name].md
  
  workflow_step_2_load_this_template:
    system_action: |-
      Load /codegen/templates/meta.codegen.schema.yaml (this file).
      Instantiate schema.input_schemas from user's collection.
  
  workflow_step_3_load_extractor_glue:
    system_action: |-
      Load /codegen/templates/glue/L9_Universal_Schema_Extractor_Glue_v6.yaml
      Load /codegen/templates/prompts/Universal-Schema-Extractor-v6.0.md
  
  workflow_step_4_execute_phase_0:
    user_action: |-
      Review dependency graph. Confirm extraction order.
      Sign off on locked TODO plan.
      "I've read the TODOs. I understand the scope. Proceed."
  
  workflow_step_5_invoke_extractor:
    user_action: |-
      Copy-paste to Claude/Cursor:
      
      "Use this meta schema + extractor glue + these 5 input schemas.
       Follow phases 0-6. Generate production code with zero TODOs.
       
       Input files:
       [Attach: meta.codegen.schema.yaml]
       [Attach: Glue file]
       [Attach: Extractor prompt]
       [Attach: Input schema collection]
       
       Output: All 5 agents extracted sequentially with full evidence report."
  
  workflow_step_6_review_evidence_report:
    user_action: |-
      Read entire evidence report (all 10 sections).
      Verify: All TODOs executed? No drift? Tests pass?
      Sign off: "Evidence report accepted. Ready for deployment."
  
  workflow_step_7_deploy:
    user_action: |-
      Run integration tests.
      Push to repo.
      Deploy to VPS.
      Notify governance.

---

## APPENDIX A: USAGE EXAMPLES

examples:
  
  example_1_tensoraios_ecosystem:
    description: Extract 5 agents (TensorAIOS, Main, PlastOS Adapter, Trainer, Auditor)
    input_file: Example-L9_Tensor-AIOS_Layer_Schemas_v6.md + example-L9_Tensor_MainAgent_Schema_v6.yaml
    collection_name: tensoraios_ecosystem
    total_agents: 5
    total_expected_modules: ~100
    total_expected_docs: ~30
    total_expected_tests: ~50
    estimated_duration_hours: 4-6
    extraction_sequence: |-
      1. TensorAIOS Core (L9/core/tensoraios)
      2. Main Agent (L9/agents/main)
      3. PlastOS Adapter (L9/agents/adapters/plastos)
      4. Tensor Trainer (L9/orchestration/tensor_trainer)
      5. Tensor Auditor (L9/governance/tensor_auditor)
    expected_output: |-
      - /codegen/extractions/tensoraios_ecosystem_[timestamp]/code/
      - /codegen/extractions/tensoraios_ecosystem_[timestamp]/docs/
      - /codegen/extractions/tensoraios_ecosystem_[timestamp]/tests/
      - /codegen/extractions/tensoraios_ecosystem_[timestamp]/manifests/
      - evidence_report_tensoraios_ecosystem.md (all 10 sections)

---

## APPENDIX B: FAQ & TROUBLESHOOTING

faq:
  
  q_what_if_agent_has_missing_dependency:
    answer: |-
      Phase 1 baseline will fail. Report will show which dependency missing.
      Options:
      1. Extract that dependency first (adjust extraction_order)
      2. Mock the dependency (for testing only)
      3. Create dependency stub (L9_ENABLE_CODEGEN_STRICT_MODE prevents this)
  
  q_what_if_generated_code_has_todo:
    answer: |-
      Phase 2 implementation will mark as FAILED if L9_ENABLE_CODEGEN_STRICT_MODE=true.
      All generated code must be production-grade (zero TODOs, zero placeholders).
      Extractor must provide complete implementations.
  
  q_what_if_tests_dont_pass:
    answer: |-
      Phase 4 will fail if test_coverage < 85% or tests don't pass.
      Extractor must generate working tests that exercise all code paths.
      Report gap in evidence_report section 7.
  
  q_how_do_i_run_extraction_in_parallel:
    answer: |-
      After phase 1-3 (sequential), agents 4+ can run in parallel if they
      share only read-only dependencies. Set orchestration.parallel_after_phase: 3
      Reduces total time by ~30%.
  
  q_what_is_the_evidence_report_for:
    answer: |-
      Prove to governance + audit that extraction was deterministic,
      complete, and production-ready. All 10 sections required.
      Evidence report is your sign-off artifact for deployment.

---

end_of_meta_schema
