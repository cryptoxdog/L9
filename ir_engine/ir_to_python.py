"""
L9 IR Engine - IR to Python Compiler
=====================================

Converts ModuleIR into Python source code using Jinja2 templates
and optional SymPy integration for symbolic expressions.

Key Features:
- Jinja2 templates for structural Python code (classes, methods, imports)
- SymPy CodeGenerator for symbolic/mathematical expressions
- Template caching for performance
- Multiple output files from single IR

Version: 1.0.0
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict, List, Optional

import structlog

try:
    import jinja2
    HAS_JINJA2 = True
except ImportError:
    HAS_JINJA2 = False

from ir_engine.compile_meta_to_ir import (
    ModuleIR,
    GenerationTarget,
    PacketSpec,
    TestSpec,
)

logger = structlog.get_logger(__name__)


# =============================================================================
# SYMPY INTEGRATION (OPTIONAL)
# =============================================================================

try:
    from services.symbolic_computation.core import CodeGenerator as SymPyCodeGenerator
    HAS_SYMPY = True
except ImportError:
    HAS_SYMPY = False
    SymPyCodeGenerator = None  # type: ignore


# =============================================================================
# TEMPLATE DEFINITIONS
# =============================================================================

# Inline templates for code generation (Jinja2 format)
# These can be moved to external files for more complex projects

ADAPTER_TEMPLATE = '''"""
{{ module_name }} Adapter
{{ '=' * (module_name | length + 8) }}

{{ description }}

Auto-generated by L9 CodeGenAgent from Module-Spec v2.4.
"""

from __future__ import annotations

from typing import Any, Dict, Optional

import structlog
{%- for import_line in imports %}
{{ import_line }}
{%- endfor %}

logger = structlog.get_logger(__name__)


class {{ class_name }}Validator:
    """Validates incoming {{ module_id }} requests."""
    
    def __init__(self, signing_secret: str):
        """
        Initialize validator.
        
        Args:
            signing_secret: Secret for HMAC signature verification
        """
        self.signing_secret = signing_secret
        logger.info("{{ module_id }}_validator_initialized")
    
    def validate_signature(
        self,
        body: bytes,
        signature: str,
        timestamp: str,
    ) -> bool:
        """
        Validate request signature.
        
        Args:
            body: Raw request body
            signature: Signature from header
            timestamp: Timestamp from header
            
        Returns:
            True if valid, False otherwise
        """
        # TODO: Implement HMAC-SHA256 validation
        import hmac
        import hashlib
        
        expected = hmac.new(
            self.signing_secret.encode(),
            f"{timestamp}:{body.decode()}".encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(signature, expected)


class {{ class_name }}Normalizer:
    """Normalizes {{ module_id }} payloads to L9 format."""
    
    def normalize(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Normalize payload to L9 format.
        
        Args:
            payload: Raw payload from {{ module_id }}
            
        Returns:
            Normalized payload
        """
        return {
            "source": "{{ module_id }}",
            "content": payload,
            "normalized": True,
        }
'''

ROUTE_TEMPLATE = '''"""
{{ module_name }} Routes
{{ '=' * (module_name | length + 7) }}

FastAPI routes for {{ module_id }}.

Auto-generated by L9 CodeGenAgent from Module-Spec v2.4.
"""

from __future__ import annotations

from typing import Any, Dict

import structlog
from fastapi import APIRouter, Depends, Header, HTTPException, Request

logger = structlog.get_logger(__name__)

router = APIRouter(prefix="/{{ module_id }}", tags=["{{ module_id }}"])


{%- for route in inbound_routes %}

@router.{{ route.method | lower }}("{{ route.route }}")
async def {{ route.name | replace('-', '_') }}(
    request: Request,
    {%- if route.headers %}
    {%- for header in route.headers %}
    {{ header | lower | replace('-', '_') | replace('x_', '') }}: str = Header(..., alias="{{ header }}"),
    {%- endfor %}
    {%- endif %}
) -> Dict[str, Any]:
    """
    Handle {{ route.name }} request.
    
    Args:
        request: FastAPI request object
        
    Returns:
        Response payload
    """
    body = await request.body()
    
    # TODO: Validate and process request
    logger.info(
        "{{ module_id }}_request_received",
        route="{{ route.route }}",
        method="{{ route.method }}",
    )
    
    return {"status": "ok", "module": "{{ module_id }}"}

{%- endfor %}


@router.get("/health")
async def health_check() -> Dict[str, str]:
    """Health check endpoint."""
    return {"status": "healthy", "module": "{{ module_id }}"}
'''

INGEST_TEMPLATE = '''"""
{{ module_name }} Ingest Handler
{{ '=' * (module_name | length + 15) }}

Handles {{ module_id }} event ingestion and packet creation.

Auto-generated by L9 CodeGenAgent from Module-Spec v2.4.
"""

from __future__ import annotations

from typing import Any, Dict, List
from uuid import uuid5, NAMESPACE_DNS

import structlog
from memory.models import PacketEnvelopeIn

logger = structlog.get_logger(__name__)


{%- for packet in packets %}

def create_{{ packet.packet_type | replace('.', '_') }}_packet(
    payload: Dict[str, Any],
    {%- for field in packet.required_metadata %}
    {{ field }}: str,
    {%- endfor %}
) -> PacketEnvelopeIn:
    """
    Create {{ packet.packet_type }} packet.
    
    Args:
        payload: Event payload
        {%- for field in packet.required_metadata %}
        {{ field }}: {{ field | replace('_', ' ') | title }}
        {%- endfor %}
        
    Returns:
        PacketEnvelopeIn ready for ingestion
    """
    return PacketEnvelopeIn(
        kind="{{ packet.packet_type }}",
        source="{{ module_id }}",
        payload=payload,
        metadata={
            {%- for field in packet.required_metadata %}
            "{{ field }}": {{ field }},
            {%- endfor %}
        },
    )

{%- endfor %}


async def handle_{{ module_id }}_events(
    events: List[Dict[str, Any]],
    substrate_service: Any,
) -> int:
    """
    Handle batch of {{ module_id }} events.
    
    Args:
        events: List of event payloads
        substrate_service: Memory substrate service instance
        
    Returns:
        Number of events processed
    """
    processed = 0
    
    for event in events:
        try:
            # Generate deterministic thread UUID
            event_id = event.get("id", str(uuid5(NAMESPACE_DNS, str(event))))
            thread_uuid = str(uuid5(NAMESPACE_DNS, f"{{ module_id }}:{event_id}"))
            
            # Create packet
            packet = create_{{ module_id }}_in_packet(
                payload=event,
                task_id=event_id,
                thread_uuid=thread_uuid,
                source="{{ module_id }}",
                tool_id="{{ module_id }}_adapter",
            )
            
            # Ingest
            await substrate_service.write_packet(packet)
            processed += 1
            
        except Exception as e:
            logger.error(
                "{{ module_id }}_event_failed",
                event_id=event.get("id"),
                error=str(e),
            )
    
    logger.info(
        "{{ module_id }}_events_processed",
        total=len(events),
        processed=processed,
    )
    
    return processed
'''

TEST_TEMPLATE = '''"""
{{ module_name }} Tests
{{ '=' * (module_name | length + 6) }}

Unit tests for {{ module_id }}.

Auto-generated by L9 CodeGenAgent from Module-Spec v2.4.
"""

from __future__ import annotations

import pytest

from api.{{ module_id }}_adapter import {{ class_name }}Validator, {{ class_name }}Normalizer


# =============================================================================
# FIXTURES
# =============================================================================


@pytest.fixture
def validator() -> {{ class_name }}Validator:
    """Create validator instance."""
    return {{ class_name }}Validator(signing_secret="test_secret")


@pytest.fixture
def normalizer() -> {{ class_name }}Normalizer:
    """Create normalizer instance."""
    return {{ class_name }}Normalizer()


# =============================================================================
# POSITIVE TESTS
# =============================================================================

{%- for test in tests if test.is_positive %}


def {{ test.test_function }}(
    {%- if 'validator' in test.test_function %}
    validator: {{ class_name }}Validator,
    {%- endif %}
    {%- if 'normalizer' in test.test_function %}
    normalizer: {{ class_name }}Normalizer,
    {%- endif %}
) -> None:
    """
    {{ test.description }}
    
    Acceptance ID: {{ test.acceptance_id }}
    """
    # TODO: Implement test
    pass

{%- endfor %}


# =============================================================================
# NEGATIVE TESTS
# =============================================================================

{%- for test in tests if not test.is_positive %}


def {{ test.test_function }}(
    validator: {{ class_name }}Validator,
) -> None:
    """
    {{ test.description }}
    
    Acceptance ID: {{ test.acceptance_id }}
    """
    # TODO: Implement test
    pass

{%- endfor %}
'''

DOC_TEMPLATE = '''# {{ module_name }}

{{ description }}

## Quick Start

```bash
# Set required environment variables
{%- for env in required_env_vars %}
export {{ env.name }}="your_value"
{%- endfor %}

# Start the server
uvicorn api.server:app --reload
```

## Environment Variables

### Required

| Variable | Description |
|----------|-------------|
{%- for env in required_env_vars %}
| `{{ env.name }}` | {{ env.description }} |
{%- endfor %}

### Optional

| Variable | Description | Default |
|----------|-------------|---------|
{%- for env in optional_env_vars %}
| `{{ env.name }}` | {{ env.description }} | `{{ env.default or 'None' }}` |
{%- endfor %}

## Endpoints

{%- for route in inbound_routes %}

### {{ route.method }} {{ route.route }}

{{ route.name }}

**Headers:**
{%- for header in route.headers %}
- `{{ header }}`
{%- endfor %}

{%- endfor %}

## Packet Types

{%- for packet in packets %}
- `{{ packet.packet_type }}`
{%- endfor %}

---

*Auto-generated by L9 CodeGenAgent from Module-Spec v2.4*
'''


# =============================================================================
# TEMPLATE REGISTRY
# =============================================================================

TEMPLATES = {
    "module_adapter.py.j2": ADAPTER_TEMPLATE,
    "module_route.py.j2": ROUTE_TEMPLATE,
    "module_ingest.py.j2": INGEST_TEMPLATE,
    "module_test.py.j2": TEST_TEMPLATE,
    "module_doc.md.j2": DOC_TEMPLATE,
}


# =============================================================================
# IR TO PYTHON COMPILER
# =============================================================================


class IRToPythonCompiler:
    """
    Compiles ModuleIR to Python source code.
    
    Uses Jinja2 templates for structural code and optionally
    SymPy CodeGenerator for symbolic expressions.
    """
    
    def __init__(
        self,
        template_dir: Optional[str] = None,
        use_sympy: bool = True,
    ):
        """
        Initialize the compiler.
        
        Args:
            template_dir: Directory containing custom templates (optional)
            use_sympy: Enable SymPy for symbolic expressions
        """
        if not HAS_JINJA2:
            raise ImportError("jinja2 is required for code generation")
        
        self.template_dir = Path(template_dir) if template_dir else None
        self.use_sympy = use_sympy and HAS_SYMPY
        
        # Initialize Jinja2 environment
        if self.template_dir and self.template_dir.exists():
            self.jinja_env = jinja2.Environment(
                loader=jinja2.FileSystemLoader(str(self.template_dir)),
                trim_blocks=True,
                lstrip_blocks=True,
            )
        else:
            # Use inline templates
            self.jinja_env = jinja2.Environment(
                loader=jinja2.DictLoader(TEMPLATES),
                trim_blocks=True,
                lstrip_blocks=True,
            )
        
        # Initialize SymPy (if available)
        self.sympy_codegen: Optional[SymPyCodeGenerator] = None
        if self.use_sympy and SymPyCodeGenerator:
            self.sympy_codegen = SymPyCodeGenerator()
        
        logger.info(
            "ir_to_python_compiler_initialized",
            has_jinja2=HAS_JINJA2,
            has_sympy=self.use_sympy,
            template_dir=str(self.template_dir) if self.template_dir else "inline",
        )
    
    def compile(self, ir: ModuleIR) -> Dict[str, str]:
        """
        Compile ModuleIR to Python source files.
        
        Args:
            ir: ModuleIR from MetaContract compilation
            
        Returns:
            Dictionary mapping file paths to source code
        """
        logger.info("compiling_ir_to_python", module_id=ir.module_id)
        
        files: Dict[str, str] = {}
        
        # Build template context
        context = self._build_context(ir)
        
        # Generate each target
        for target in ir.targets:
            try:
                source = self._render_target(target, context)
                files[target.path] = source
                logger.debug(
                    "target_generated",
                    path=target.path,
                    target_type=target.target_type,
                    lines=source.count('\n'),
                )
            except Exception as e:
                logger.error(
                    "target_generation_failed",
                    path=target.path,
                    error=str(e),
                )
        
        logger.info(
            "ir_compilation_complete",
            module_id=ir.module_id,
            file_count=len(files),
        )
        
        return files
    
    def compile_single(
        self,
        ir: ModuleIR,
        target_type: str,
    ) -> str:
        """
        Compile a single target type from IR.
        
        Args:
            ir: ModuleIR instance
            target_type: Type of target (adapter, route, ingest, test, doc)
            
        Returns:
            Generated source code
        """
        context = self._build_context(ir)
        template_name = self._get_template_for_type(target_type)
        
        template = self.jinja_env.get_template(template_name)
        return template.render(**context)
    
    # =========================================================================
    # PRIVATE METHODS
    # =========================================================================
    
    def _build_context(self, ir: ModuleIR) -> Dict[str, Any]:
        """Build template context from IR."""
        # Pascal case class name
        class_name = "".join(
            word.capitalize() 
            for word in ir.module_id.replace("_", " ").split()
        )
        
        return {
            "module_id": ir.module_id,
            "module_name": ir.module_name,
            "description": ir.description,
            "class_name": class_name,
            "imports": ir.get_imports(),
            "packets": [
                {
                    "packet_type": p.packet_type,
                    "required_metadata": p.required_metadata,
                    "class_name": p.class_name,
                }
                for p in ir.packets
            ],
            "tests": [
                {
                    "test_function": t.test_function,
                    "description": t.description,
                    "is_positive": t.is_positive,
                    "acceptance_id": t.acceptance_id,
                }
                for t in ir.tests
            ],
            "inbound_routes": ir.inbound_routes,
            "outbound_clients": ir.outbound_clients,
            "required_env_vars": ir.required_env_vars,
            "optional_env_vars": ir.optional_env_vars,
            "counters": ir.counters,
            "histograms": ir.histograms,
            **ir.context,
        }
    
    def _render_target(
        self,
        target: GenerationTarget,
        context: Dict[str, Any],
    ) -> str:
        """Render a single generation target."""
        template_name = target.template_name or self._get_template_for_type(target.target_type)
        
        # Merge target-specific context
        merged_context = {**context, **target.context}
        
        try:
            template = self.jinja_env.get_template(template_name)
            return template.render(**merged_context)
        except jinja2.TemplateNotFound:
            logger.warning(
                "template_not_found",
                template_name=template_name,
                target_type=target.target_type,
            )
            # Fall back to a simple stub
            return self._generate_stub(target, merged_context)
    
    def _get_template_for_type(self, target_type: str) -> str:
        """Get template name for target type."""
        mapping = {
            "adapter": "module_adapter.py.j2",
            "client": "module_adapter.py.j2",  # Reuse adapter template
            "route": "module_route.py.j2",
            "ingest": "module_ingest.py.j2",
            "test": "module_test.py.j2",
            "smoke_test": "module_test.py.j2",  # Reuse test template
            "doc": "module_doc.md.j2",
        }
        return mapping.get(target_type, "module_adapter.py.j2")
    
    def _generate_stub(
        self,
        target: GenerationTarget,
        context: Dict[str, Any],
    ) -> str:
        """Generate a minimal stub file."""
        module_id = context.get("module_id", "unknown")
        
        if target.path.endswith(".py"):
            return f'''"""
{context.get('module_name', 'Module')} - {target.target_type}

Auto-generated stub by L9 CodeGenAgent.
"""

# TODO: Implement {target.target_type} for {module_id}
'''
        elif target.path.endswith(".md"):
            return f'''# {context.get('module_name', 'Module')}

{context.get('description', 'No description')}

*Auto-generated stub by L9 CodeGenAgent*
'''
        else:
            return f"# Stub for {target.path}\n"


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================


def compile_ir_to_python(ir: ModuleIR) -> Dict[str, str]:
    """
    Compile ModuleIR to Python source files.
    
    Args:
        ir: ModuleIR from MetaContract compilation
        
    Returns:
        Dictionary mapping file paths to source code
    """
    compiler = IRToPythonCompiler()
    return compiler.compile(ir)


def compile_ir_to_single(ir: ModuleIR, target_type: str) -> str:
    """
    Compile a single target type from IR.
    
    Args:
        ir: ModuleIR instance
        target_type: Type of target (adapter, route, ingest, test, doc)
        
    Returns:
        Generated source code
    """
    compiler = IRToPythonCompiler()
    return compiler.compile_single(ir, target_type)

