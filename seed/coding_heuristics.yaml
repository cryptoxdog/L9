version: "1.0"
type: "coding_heuristics_library"
description: "L9 World Model seed heuristics for code quality and best practices"
created_at: "2024-12-08"
schema_version: "1.0.1"

heuristics:
  # =============================================================================
  # ERROR HANDLING
  # =============================================================================

  - id: "rule.no_swallowed_exceptions"
    rule: "Never swallow exceptions without logging."
    severity: "high"
    category: "error_handling"
    description: "Silent exception handling hides bugs and makes debugging impossible."
    example_good: |
      try:
          risky_op()
      except Exception as e:
          logger.error(f"Operation failed: {e}")
          raise
    example_bad: |
      try:
          risky_op()
      except:
          pass
    auto_fix_strategy:
      - "wrap except in logging + re-raise"
      - "if suppression intended, add explicit comment explaining why"
    related_patterns:
      - "pattern.chain_of_responsibility"

  - id: "rule.specific_exceptions"
    rule: "Catch specific exceptions, not bare except or Exception."
    severity: "medium"
    category: "error_handling"
    description: "Broad exception catching hides unexpected errors and makes debugging harder."
    example_good: |
      try:
          result = json.loads(data)
      except json.JSONDecodeError as e:
          logger.warning(f"Invalid JSON: {e}")
          result = {}
    example_bad: |
      try:
          result = json.loads(data)
      except:
          result = {}
    auto_fix_strategy:
      - "identify specific exception types that can occur"
      - "add separate handlers for each exception type"
    related_patterns: []

  - id: "rule.error_context"
    rule: "Include context when raising or logging errors."
    severity: "medium"
    category: "error_handling"
    description: "Error messages without context make debugging time-consuming."
    example_good: |
      raise ValueError(f"Invalid user_id '{user_id}': must be positive integer")
    example_bad: |
      raise ValueError("Invalid input")
    auto_fix_strategy:
      - "add variable values to error message"
      - "include operation context"
    related_patterns: []

  # =============================================================================
  # CODE STRUCTURE
  # =============================================================================

  - id: "rule.no_god_objects"
    rule: "Avoid modules that accumulate too many responsibilities."
    severity: "medium"
    category: "structure"
    description: "God objects violate single responsibility and become maintenance nightmares."
    example_good: "Split into orchestrator + adapters + domain logic."
    example_bad: "A 500-line class with 20 methods handling UI, business logic, and DB."
    auto_fix_strategy:
      - "identify distinct responsibilities"
      - "extract each into dedicated module"
      - "use orchestrator pattern to coordinate"
    related_patterns:
      - "pattern.orchestrator"
      - "pattern.facade"

  - id: "rule.single_responsibility"
    rule: "Each module/class should have one reason to change."
    severity: "medium"
    category: "structure"
    description: "Mixed responsibilities lead to fragile code and ripple effects from changes."
    example_good: |
      class UserRepository:
          def save(self, user): ...
          def find_by_id(self, id): ...
      
      class UserValidator:
          def validate(self, user): ...
    example_bad: |
      class UserService:
          def save(self, user): ...
          def validate(self, user): ...
          def send_email(self, user): ...
          def generate_report(self, user): ...
    auto_fix_strategy:
      - "list all responsibilities"
      - "create separate class for each"
      - "inject dependencies"
    related_patterns:
      - "pattern.bridge"

  - id: "rule.max_function_length"
    rule: "Functions should be under 50 lines; prefer under 20."
    severity: "low"
    category: "structure"
    description: "Long functions are hard to understand, test, and maintain."
    example_good: "Break into smaller functions with descriptive names."
    example_bad: "A 200-line function with nested conditionals and loops."
    auto_fix_strategy:
      - "identify logical blocks"
      - "extract to named helper functions"
      - "use early returns to reduce nesting"
    related_patterns: []

  - id: "rule.max_nesting"
    rule: "Limit nesting depth to 3 levels."
    severity: "low"
    category: "structure"
    description: "Deep nesting increases cognitive load and error probability."
    example_good: |
      if not user:
          return None
      if not user.is_active:
          return None
      return process_user(user)
    example_bad: |
      if user:
          if user.is_active:
              if user.has_permission:
                  if user.quota > 0:
                      return process_user(user)
    auto_fix_strategy:
      - "use early returns for guard clauses"
      - "extract nested logic to functions"
    related_patterns: []

  # =============================================================================
  # NAMING & READABILITY
  # =============================================================================

  - id: "rule.descriptive_names"
    rule: "Use descriptive names that reveal intent."
    severity: "medium"
    category: "naming"
    description: "Code is read more often than written. Clear names reduce cognitive load."
    example_good: |
      def calculate_monthly_revenue(transactions: list[Transaction]) -> Decimal:
          return sum(t.amount for t in transactions if t.is_completed)
    example_bad: |
      def calc(t):
          return sum(x.a for x in t if x.c)
    auto_fix_strategy:
      - "rename single-letter variables"
      - "use domain terminology"
      - "include units in names where relevant"
    related_patterns: []

  - id: "rule.consistent_naming"
    rule: "Follow consistent naming conventions throughout codebase."
    severity: "low"
    category: "naming"
    description: "Inconsistent naming creates confusion and reduces searchability."
    example_good: |
      # All use snake_case for functions
      def get_user(): ...
      def create_order(): ...
      def process_payment(): ...
    example_bad: |
      def getUser(): ...
      def create_order(): ...
      def ProcessPayment(): ...
    auto_fix_strategy:
      - "establish naming convention"
      - "use automated linting"
      - "batch rename violations"
    related_patterns: []

  - id: "rule.avoid_magic_numbers"
    rule: "Replace magic numbers with named constants."
    severity: "low"
    category: "naming"
    description: "Magic numbers obscure meaning and create maintenance issues."
    example_good: |
      MAX_RETRY_ATTEMPTS = 3
      TIMEOUT_SECONDS = 30
      
      for attempt in range(MAX_RETRY_ATTEMPTS):
          result = fetch_with_timeout(TIMEOUT_SECONDS)
    example_bad: |
      for attempt in range(3):
          result = fetch_with_timeout(30)
    auto_fix_strategy:
      - "identify repeated literals"
      - "extract to named constants"
      - "group related constants"
    related_patterns: []

  # =============================================================================
  # ASYNC & CONCURRENCY
  # =============================================================================

  - id: "rule.await_all_coroutines"
    rule: "Always await coroutines; never let them fire and forget."
    severity: "high"
    category: "async"
    description: "Unawaited coroutines may never run or silently fail."
    example_good: |
      async def process():
          result = await fetch_data()
          await save_result(result)
    example_bad: |
      async def process():
          fetch_data()  # Coroutine not awaited!
          save_result(result)
    auto_fix_strategy:
      - "add await keyword"
      - "if fire-and-forget needed, use asyncio.create_task() with error handling"
    related_patterns: []

  - id: "rule.gather_for_parallel"
    rule: "Use asyncio.gather() for concurrent coroutines."
    severity: "medium"
    category: "async"
    description: "Sequential awaits waste time when operations are independent."
    example_good: |
      async def fetch_all():
          results = await asyncio.gather(
              fetch_users(),
              fetch_orders(),
              fetch_inventory()
          )
          return results
    example_bad: |
      async def fetch_all():
          users = await fetch_users()
          orders = await fetch_orders()
          inventory = await fetch_inventory()
          return users, orders, inventory
    auto_fix_strategy:
      - "identify independent awaits"
      - "wrap in asyncio.gather()"
    related_patterns: []

  - id: "rule.no_blocking_in_async"
    rule: "Never call blocking I/O in async functions."
    severity: "high"
    category: "async"
    description: "Blocking calls in async code freeze the entire event loop."
    example_good: |
      async def read_file(path):
          async with aiofiles.open(path) as f:
              return await f.read()
    example_bad: |
      async def read_file(path):
          with open(path) as f:  # Blocking!
              return f.read()
    auto_fix_strategy:
      - "use async versions of I/O libraries"
      - "run blocking code in executor"
    related_patterns: []

  # =============================================================================
  # TYPE SAFETY
  # =============================================================================

  - id: "rule.type_hints"
    rule: "Use type hints for function signatures and class attributes."
    severity: "medium"
    category: "typing"
    description: "Type hints enable IDE support, documentation, and static analysis."
    example_good: |
      def process_user(user_id: int, include_orders: bool = False) -> User:
          ...
    example_bad: |
      def process_user(user_id, include_orders=False):
          ...
    auto_fix_strategy:
      - "add type hints to all public functions"
      - "use Optional[] for nullable types"
      - "run mypy for validation"
    related_patterns: []

  - id: "rule.validate_at_boundaries"
    rule: "Validate inputs at system boundaries, trust internal code."
    severity: "medium"
    category: "typing"
    description: "Validate user input and external API responses; don't re-validate everywhere."
    example_good: |
      # At API boundary
      @app.post("/users")
      async def create_user(user_in: UserCreate):  # Pydantic validates
          return await service.create_user(user_in)
      
      # Internal code trusts validated input
      async def create_user(self, user_in: UserCreate) -> User:
          return await self.repo.save(user_in)
    example_bad: |
      async def create_user(self, data: dict) -> User:
          if not data.get("email"):  # Redundant validation
              raise ValueError("Email required")
          if not data.get("name"):
              raise ValueError("Name required")
          ...
    auto_fix_strategy:
      - "use Pydantic at boundaries"
      - "remove redundant internal validation"
    related_patterns:
      - "pattern.adapter"

  # =============================================================================
  # TESTING
  # =============================================================================

  - id: "rule.test_behavior_not_implementation"
    rule: "Test observable behavior, not internal implementation."
    severity: "medium"
    category: "testing"
    description: "Implementation-coupled tests break on refactoring and miss actual bugs."
    example_good: |
      def test_user_creation():
          user = create_user("alice@example.com")
          assert user.email == "alice@example.com"
          assert user.is_active == True
    example_bad: |
      def test_user_creation():
          user = create_user("alice@example.com")
          assert user._internal_state == {"validated": True}
          assert user._db_calls == 1
    auto_fix_strategy:
      - "test public API only"
      - "mock at boundaries, not internals"
    related_patterns: []

  - id: "rule.arrange_act_assert"
    rule: "Structure tests with Arrange-Act-Assert pattern."
    severity: "low"
    category: "testing"
    description: "Clear test structure improves readability and maintenance."
    example_good: |
      def test_order_total():
          # Arrange
          order = Order()
          order.add_item(Item(price=10.00, quantity=2))
          order.add_item(Item(price=5.00, quantity=1))
          
          # Act
          total = order.calculate_total()
          
          # Assert
          assert total == 25.00
    example_bad: |
      def test_order_total():
          assert Order().add_item(Item(10, 2)).add_item(Item(5, 1)).calculate_total() == 25
    auto_fix_strategy:
      - "separate setup, action, and assertion"
      - "add comments for clarity"
    related_patterns: []

  # =============================================================================
  # L9-SPECIFIC HEURISTICS
  # =============================================================================

  - id: "rule.packet_immutability"
    rule: "Never mutate PacketEnvelopes; use with_update() for changes."
    severity: "high"
    category: "l9_native"
    description: "PacketEnvelope immutability is a core L9 invariant for provenance tracking."
    example_good: |
      new_packet = original_packet.with_update(
          payload={"updated": True}
      )
    example_bad: |
      packet.payload["updated"] = True  # Violates immutability!
    auto_fix_strategy:
      - "use with_update() method"
      - "create new packet with changes"
    related_patterns:
      - "pattern.packet_envelope"

  - id: "rule.memory_substrate_writes"
    rule: "All significant events should be written to memory substrate."
    severity: "medium"
    category: "l9_native"
    description: "Memory substrate provides audit trail and enables semantic search over history."
    example_good: |
      async def process_task(self, task: Task):
          result = await self._execute(task)
          await self._substrate.write_packet(PacketEnvelopeIn(
              packet_type="task_result",
              payload=result.to_dict(),
              metadata={"agent": self.agent_id}
          ))
          return result
    example_bad: |
      async def process_task(self, task: Task):
          return await self._execute(task)  # No audit trail!
    auto_fix_strategy:
      - "identify significant events"
      - "add substrate write after each"
    related_patterns:
      - "pattern.packet_envelope"

  - id: "rule.ir_validation"
    rule: "Always validate IR before execution."
    severity: "high"
    category: "l9_native"
    description: "Unvalidated IR can lead to incorrect or dangerous actions."
    example_good: |
      async def execute_ir(self, ir: FinalIR):
          validation = await self._validator.validate(ir)
          if not validation.is_valid:
              raise IRValidationError(validation.errors)
          return await self._executor.execute(ir)
    example_bad: |
      async def execute_ir(self, ir: FinalIR):
          return await self._executor.execute(ir)  # No validation!
    auto_fix_strategy:
      - "add validation step before execution"
      - "handle validation errors"
    related_patterns:
      - "pattern.ir_pipeline"

  - id: "rule.cell_convergence"
    rule: "Collaborative cells must have convergence criteria."
    severity: "medium"
    category: "l9_native"
    description: "Without convergence criteria, deliberation can loop indefinitely."
    example_good: |
      async def deliberate(self, topic: str, max_rounds: int = 5):
          for round in range(max_rounds):
              proposal = await self._producer.propose()
              critique = await self._critic.critique(proposal)
              if critique.is_accepted:
                  return proposal
          return await self._fallback()
    example_bad: |
      async def deliberate(self, topic: str):
          while True:  # No termination condition!
              proposal = await self._producer.propose()
              critique = await self._critic.critique(proposal)
    auto_fix_strategy:
      - "add max_rounds parameter"
      - "define acceptance criteria"
      - "implement fallback strategy"
    related_patterns:
      - "pattern.collaborative_cell"

  - id: "rule.world_model_consistency"
    rule: "Update world model after state-changing operations."
    severity: "medium"
    category: "l9_native"
    description: "Stale world model leads to incorrect reasoning and decisions."
    example_good: |
      async def process_action(self, action: Action):
          result = await self._execute(action)
          await self._world_model.apply_update(
              update_type="entity_update",
              target_id=action.target_id,
              data=result.state_changes
          )
          return result
    example_bad: |
      async def process_action(self, action: Action):
          return await self._execute(action)  # World model not updated!
    auto_fix_strategy:
      - "identify state-changing operations"
      - "add world model update after each"
    related_patterns:
      - "pattern.world_model_query"

metadata:
  total_heuristics: 22
  categories:
    error_handling: 3
    structure: 4
    naming: 3
    async: 3
    typing: 2
    testing: 2
    l9_native: 5
  severity_counts:
    high: 5
    medium: 12
    low: 5
  last_updated: "2024-12-08"

