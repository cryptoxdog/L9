"""
L9 Research Factory - Universal Extractor
==========================================

Generates production code from YAML agent schemas using Jinja2 templates.

The extraction process:
1. Parse schema into normalized AST (via schema_parser)
2. Validate against rules (via schema_validator)
3. Resolve dependencies via glue layer (via glue_resolver)
4. Apply extraction templates
5. Generate code, tests, docs, manifest
6. Validate outputs against quality gates

Version: 1.0.0
"""

from __future__ import annotations

import json
import logging
import os
import shutil
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

from jinja2 import Environment, FileSystemLoader, select_autoescape

from services.research_factory.schema_parser import AgentSchema, parse_schema
from services.research_factory.schema_validator import (
    SchemaValidator,
    ValidationResult,
    validate_schema,
)
from services.research_factory.glue_resolver import (
    GlueConfig,
    GlueResolver,
    create_empty_glue_config,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Constants
# =============================================================================

TEMPLATES_DIR = Path(__file__).parent / "templates"


# =============================================================================
# Extraction Result Models
# =============================================================================

@dataclass
class GeneratedFile:
    """A file generated by the extractor."""
    path: Path
    content: str
    template: str
    size_bytes: int = 0
    
    def __post_init__(self):
        self.size_bytes = len(self.content.encode("utf-8"))


@dataclass
class ExtractionManifest:
    """Manifest of extraction results."""
    agent_id: str
    agent_name: str
    schema_version: str
    extracted_at: datetime
    output_dir: str
    files: list[str] = field(default_factory=list)
    total_lines: int = 0
    total_bytes: int = 0
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "agent_id": self.agent_id,
            "agent_name": self.agent_name,
            "schema_version": self.schema_version,
            "extracted_at": self.extracted_at.isoformat(),
            "output_dir": self.output_dir,
            "files": self.files,
            "total_lines": self.total_lines,
            "total_bytes": self.total_bytes,
        }


@dataclass
class ExtractionResult:
    """Result of the extraction process."""
    success: bool
    schema: Optional[AgentSchema] = None
    validation: Optional[ValidationResult] = None
    manifest: Optional[ExtractionManifest] = None
    generated_files: list[GeneratedFile] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    duration_ms: int = 0
    
    def add_error(self, error: str) -> None:
        self.errors.append(error)
        self.success = False
    
    def add_warning(self, warning: str) -> None:
        self.warnings.append(warning)
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "success": self.success,
            "agent_id": self.schema.get_agent_id() if self.schema else None,
            "error_count": len(self.errors),
            "warning_count": len(self.warnings),
            "errors": self.errors,
            "warnings": self.warnings,
            "file_count": len(self.generated_files),
            "manifest": self.manifest.to_dict() if self.manifest else None,
            "duration_ms": self.duration_ms,
        }


# =============================================================================
# Universal Extractor
# =============================================================================

class UniversalExtractor:
    """
    Extracts production code from YAML agent schemas.
    
    Usage:
        extractor = UniversalExtractor()
        
        result = await extractor.extract(
            schema_path="path/to/schema.yaml",
            output_dir="L9/agents/new_agent",
        )
        
        if result.success:
            print(f"Generated {len(result.generated_files)} files")
        else:
            for error in result.errors:
                print(f"Error: {error}")
    """
    
    def __init__(
        self,
        templates_dir: Optional[Path] = None,
        validator: Optional[SchemaValidator] = None,
        strict_validation: bool = False,
    ):
        """
        Initialize the extractor.
        
        Args:
            templates_dir: Directory containing Jinja2 templates
            validator: Schema validator instance
            strict_validation: If True, fail on validation warnings
        """
        self._templates_dir = templates_dir or TEMPLATES_DIR
        self._validator = validator or SchemaValidator(strict=strict_validation)
        self._strict = strict_validation
        
        # Initialize Jinja2 environment
        self._env = Environment(
            loader=FileSystemLoader(str(self._templates_dir)),
            autoescape=select_autoescape(default_for_string=False),
            trim_blocks=True,
            lstrip_blocks=True,
        )
        
        # Add custom filters
        self._env.filters["lower"] = str.lower
        self._env.filters["upper"] = str.upper
        self._env.filters["snake_case"] = self._to_snake_case
        
        logger.info(
            "UniversalExtractor initialized: templates_dir=%s, strict=%s",
            self._templates_dir,
            self._strict,
        )
    
    @staticmethod
    def _to_snake_case(s: str) -> str:
        """Convert string to snake_case."""
        import re
        s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", s)
        s = re.sub(r"([a-z\d])([A-Z])", r"\1_\2", s)
        return s.replace("-", "_").lower()
    
    # =========================================================================
    # Main Extraction API
    # =========================================================================
    
    async def extract(
        self,
        schema: AgentSchema | str | Path | dict[str, Any],
        output_dir: str | Path,
        glue: Optional[GlueConfig | str | Path] = None,
        overwrite: bool = False,
        dry_run: bool = False,
    ) -> ExtractionResult:
        """
        Extract code from a schema.
        
        Args:
            schema: Schema as AgentSchema, file path, or dict
            output_dir: Directory to write generated files
            glue: Optional glue configuration for dependencies
            overwrite: If True, overwrite existing files
            dry_run: If True, don't write files (validate only)
            
        Returns:
            ExtractionResult with generated files or errors
        """
        start_time = datetime.utcnow()
        result = ExtractionResult(success=True)
        
        try:
            # Step 1: Parse schema
            parsed_schema = self._parse_schema(schema, result)
            if not parsed_schema:
                return result
            
            result.schema = parsed_schema
            
            # Step 2: Validate schema
            validation = self._validator.validate(parsed_schema)
            result.validation = validation
            
            if not validation.valid:
                for error in validation.errors:
                    result.add_error(str(error))
                return result
            
            for warning in validation.warnings:
                result.add_warning(str(warning))
            
            # Step 3: Parse glue config
            glue_config = self._parse_glue(glue)
            
            # Step 4: Resolve dependencies
            if glue_config.wirings:
                resolver = GlueResolver(glue_config)
                has_cycle, cycle = resolver.check_circular_dependencies()
                if has_cycle:
                    result.add_error(f"Circular dependency detected: {' -> '.join(cycle)}")
                    return result
            
            # Step 5: Generate files
            output_path = Path(output_dir)
            generated = await self._generate_files(
                schema=parsed_schema,
                glue=glue_config,
                output_dir=output_path,
                result=result,
            )
            
            result.generated_files = generated
            
            # Step 6: Write files (unless dry run)
            if not dry_run:
                await self._write_files(
                    generated_files=generated,
                    output_dir=output_path,
                    overwrite=overwrite,
                    result=result,
                )
            
            # Step 7: Create manifest
            if result.success:
                result.manifest = self._create_manifest(parsed_schema, output_path, generated)
                
                if not dry_run:
                    # Write manifest
                    manifest_path = output_path / "manifest.json"
                    manifest_path.write_text(json.dumps(result.manifest.to_dict(), indent=2))
            
        except Exception as e:
            logger.exception("Extraction failed: %s", str(e))
            result.add_error(f"Extraction failed: {e}")
        
        # Calculate duration
        result.duration_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
        
        logger.info(
            "Extraction %s: agent=%s, files=%d, errors=%d, duration_ms=%d",
            "succeeded" if result.success else "failed",
            result.schema.get_agent_id() if result.schema else "unknown",
            len(result.generated_files),
            len(result.errors),
            result.duration_ms,
        )
        
        return result
    
    async def validate_only(
        self,
        schema: AgentSchema | str | Path | dict[str, Any],
    ) -> ValidationResult:
        """
        Validate a schema without extracting.
        
        Args:
            schema: Schema to validate
            
        Returns:
            ValidationResult
        """
        try:
            parsed = self._parse_schema_raw(schema)
            return self._validator.validate(parsed)
        except Exception as e:
            result = ValidationResult(valid=False)
            result.add_error("PARSE_ERROR", str(e))
            return result
    
    # =========================================================================
    # Parsing Helpers
    # =========================================================================
    
    def _parse_schema(
        self,
        schema: AgentSchema | str | Path | dict[str, Any],
        result: ExtractionResult,
    ) -> Optional[AgentSchema]:
        """Parse schema, adding errors to result on failure."""
        try:
            return self._parse_schema_raw(schema)
        except Exception as e:
            result.add_error(f"Schema parse error: {e}")
            return None
    
    def _parse_schema_raw(
        self,
        schema: AgentSchema | str | Path | dict[str, Any],
    ) -> AgentSchema:
        """Parse schema, raising on error."""
        if isinstance(schema, AgentSchema):
            return schema
        return parse_schema(schema)
    
    def _parse_glue(
        self,
        glue: Optional[GlueConfig | str | Path],
    ) -> GlueConfig:
        """Parse glue configuration."""
        if glue is None:
            return create_empty_glue_config()
        
        if isinstance(glue, GlueConfig):
            return glue
        
        path = Path(glue)
        if path.exists():
            from services.research_factory.glue_resolver import load_glue_config
            return load_glue_config(path)
        
        return create_empty_glue_config()
    
    # =========================================================================
    # Code Generation
    # =========================================================================
    
    async def _generate_files(
        self,
        schema: AgentSchema,
        glue: GlueConfig,
        output_dir: Path,
        result: ExtractionResult,
    ) -> list[GeneratedFile]:
        """Generate files from templates."""
        generated = []
        
        # Context for templates
        context = {
            "schema": schema,
            "glue": glue,
            "output_dir": str(output_dir),
            "generated_at": datetime.utcnow().isoformat(),
        }
        
        # Generate controller.py
        try:
            controller_content = self._render_template("controller.py.j2", context)
            generated.append(GeneratedFile(
                path=output_dir / "controller.py",
                content=controller_content,
                template="controller.py.j2",
            ))
        except Exception as e:
            result.add_warning(f"Failed to generate controller.py: {e}")
        
        # Generate __init__.py
        try:
            init_content = self._render_template("__init__.py.j2", context)
            generated.append(GeneratedFile(
                path=output_dir / "__init__.py",
                content=init_content,
                template="__init__.py.j2",
            ))
        except Exception as e:
            result.add_warning(f"Failed to generate __init__.py: {e}")
        
        # Generate test file
        try:
            test_content = self._render_template("test_agent.py.j2", context)
            test_dir = output_dir.parent.parent / "tests" / output_dir.name
            generated.append(GeneratedFile(
                path=test_dir / f"test_{schema.system.name.lower()}.py",
                content=test_content,
                template="test_agent.py.j2",
            ))
        except Exception as e:
            result.add_warning(f"Failed to generate test file: {e}")
        
        # Generate README.md
        try:
            readme_content = self._render_template("README.md.j2", context)
            generated.append(GeneratedFile(
                path=output_dir / "README.md",
                content=readme_content,
                template="README.md.j2",
            ))
        except Exception as e:
            result.add_warning(f"Failed to generate README.md: {e}")
        
        # Generate any additional files from cursorinstructions
        for filename in schema.cursorinstructions.generatefiles:
            if filename not in ["controller.py", "__init__.py"]:
                # For additional files, generate a stub
                stub_content = self._generate_stub_file(schema, filename)
                generated.append(GeneratedFile(
                    path=output_dir / filename,
                    content=stub_content,
                    template="stub",
                ))
        
        return generated
    
    def _render_template(self, template_name: str, context: dict[str, Any]) -> str:
        """Render a Jinja2 template."""
        template = self._env.get_template(template_name)
        return template.render(**context)
    
    def _generate_stub_file(self, schema: AgentSchema, filename: str) -> str:
        """Generate a stub file for additional files."""
        module_name = filename.replace(".py", "")
        class_name = "".join(word.title() for word in module_name.split("_"))
        
        return f'''"""
{schema.system.system} - {class_name}
{"=" * (len(schema.system.system) + len(class_name) + 3)}

Auto-generated stub by L9 Research Factory.

TODO: Implement {module_name} functionality.

Version: 1.0.0
"""

from __future__ import annotations

import logging
from typing import Any

logger = logging.getLogger(__name__)


class {class_name}:
    """
    {class_name} for {schema.system.name}.
    
    TODO: Add implementation.
    """
    
    def __init__(self):
        """Initialize {class_name}."""
        logger.info("{class_name} initialized")
    
    async def process(self, data: Any) -> Any:
        """
        Process data.
        
        Args:
            data: Input data
            
        Returns:
            Processed result
            
        TODO: Implement processing logic.
        """
        raise NotImplementedError("{class_name}.process not implemented")


__all__ = ["{class_name}"]
'''
    
    # =========================================================================
    # File Writing
    # =========================================================================
    
    async def _write_files(
        self,
        generated_files: list[GeneratedFile],
        output_dir: Path,
        overwrite: bool,
        result: ExtractionResult,
    ) -> None:
        """Write generated files to disk."""
        for gen_file in generated_files:
            try:
                # Create parent directories
                gen_file.path.parent.mkdir(parents=True, exist_ok=True)
                
                # Check if file exists
                if gen_file.path.exists() and not overwrite:
                    result.add_warning(f"File exists, skipping: {gen_file.path}")
                    continue
                
                # Write file
                gen_file.path.write_text(gen_file.content)
                logger.debug("Wrote: %s", gen_file.path)
                
            except Exception as e:
                result.add_error(f"Failed to write {gen_file.path}: {e}")
    
    # =========================================================================
    # Manifest
    # =========================================================================
    
    def _create_manifest(
        self,
        schema: AgentSchema,
        output_dir: Path,
        generated_files: list[GeneratedFile],
    ) -> ExtractionManifest:
        """Create extraction manifest."""
        total_lines = sum(
            content.count("\n") + 1
            for f in generated_files
            for content in [f.content]
        )
        total_bytes = sum(f.size_bytes for f in generated_files)
        
        return ExtractionManifest(
            agent_id=schema.get_agent_id(),
            agent_name=schema.system.name,
            schema_version=schema.metadata.version,
            extracted_at=datetime.utcnow(),
            output_dir=str(output_dir),
            files=[str(f.path) for f in generated_files],
            total_lines=total_lines,
            total_bytes=total_bytes,
        )
    
    # =========================================================================
    # Template Info
    # =========================================================================
    
    def list_templates(self) -> list[str]:
        """List available templates."""
        templates = []
        if self._templates_dir.exists():
            for f in self._templates_dir.glob("*.j2"):
                templates.append(f.name)
        return sorted(templates)
    
    def get_template_content(self, template_name: str) -> Optional[str]:
        """Get content of a template."""
        template_path = self._templates_dir / template_name
        if template_path.exists():
            return template_path.read_text()
        return None


# =============================================================================
# Convenience Functions
# =============================================================================

async def extract_agent(
    schema_path: str | Path,
    output_dir: str | Path,
    glue_path: Optional[str | Path] = None,
    overwrite: bool = False,
    dry_run: bool = False,
) -> ExtractionResult:
    """
    Extract an agent from a schema file.
    
    Args:
        schema_path: Path to YAML schema
        output_dir: Output directory
        glue_path: Optional path to glue configuration
        overwrite: Overwrite existing files
        dry_run: Don't write files
        
    Returns:
        ExtractionResult
    """
    extractor = UniversalExtractor()
    return await extractor.extract(
        schema=schema_path,
        output_dir=output_dir,
        glue=glue_path,
        overwrite=overwrite,
        dry_run=dry_run,
    )


def create_extractor(
    templates_dir: Optional[Path] = None,
    strict: bool = False,
) -> UniversalExtractor:
    """
    Create an extractor instance.
    
    Args:
        templates_dir: Optional custom templates directory
        strict: Enable strict validation
        
    Returns:
        UniversalExtractor
    """
    return UniversalExtractor(
        templates_dir=templates_dir,
        strict_validation=strict,
    )


# =============================================================================
# Public API
# =============================================================================

__all__ = [
    # Main class
    "UniversalExtractor",
    # Result models
    "ExtractionResult",
    "ExtractionManifest",
    "GeneratedFile",
    # Functions
    "extract_agent",
    "create_extractor",
]

